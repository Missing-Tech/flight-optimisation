\subsection{_types.py}
\begin{minted}[breaklines,fontsize=\small]{python}
from collections import namedtuple
from typing import TypedDict
import pandas as pd


class FlightPoint(TypedDict):
    longitude: float
    latitude: float
    altitude_ft: float
    altitude: float or None
    level: float or None
    thrust: float or None
    time: pd.Timestamp or None
    aircraft_mass: float or None
    segment_length: float or None
    course: float or None
    climb_angle: float or None
    true_airspeed: float or None
    heading: float or None
    ground_speed: float or None
    fuel_flow: float or None
    CO2: float or None


class Objectives(TypedDict):
    contrail: float or None
    co2: float or None
    time: float or None
    cocip: float or None


FlightPath = list[FlightPoint]

WindVector = namedtuple("WindVector", "u v")

IndexPoint3D = namedtuple("IndexPoint3D", "lat lon alt")
IndexPath = list[IndexPoint3D]

Point2D = namedtuple("Point2D", "lat lon")
Point3D = namedtuple("Point3D", "lat lon alt")
Point4D = namedtuple("Point4D", "lat lon alt time")

Path2D = list[Point2D]
Grid2D = list[list[Point2D]]
Grid3D = dict[int, Grid2D]

\end{minted}
\subsection{config.py}
\begin{minted}[breaklines,fontsize=\small]{python}
import pandas as pd
from objectives import ContrailObjective, CO2Objective, TimeObjective, CocipObjective

import typing

if typing.TYPE_CHECKING:
    from _types import Point2D
    from objectives import Objective


class Config:
    NAME: str = "overall"
    # Flight Path
    DEPARTURE_AIRPORT: "Point2D" = (50.74045, -3.00313)
    DESTINATION_AIRPORT: "Point2D" = (
        41.82151,
        -71.12919,
    )  # ToD for the real flight path
    DEPARTURE_DATE: pd.Timestamp = pd.Timestamp(
        year=2024, month=1, day=31, hour=13, minute=45, second=57
    )
    WEATHER_BOUND: pd.Timedelta = (
        pd.Timedelta("12h") - pd.Timedelta("45m") - pd.Timedelta("57s")
    )
    NO_OF_POINTS: int = 10
    GRID_WIDTH: int = 40
    GRID_SPACING: int = 20  # km

    # ACO
    EVAPORATION_RATE: float = 0.3
    CO2_WEIGHT: float = 1
    CONTRAIL_WEIGHT: float = 1
    TIME_WEIGHT: float = 1
    PHEROMONE_WEIGHT: float = 2
    HEURISTIC_WEIGHT: float = 1
    TAU_MIN: float = 0.1
    TAU_MAX: float = 1
    NO_OF_ANTS: int = 8
    NO_OF_ITERATIONS: int = 1

    # Aircraft
    AIRCRAFT_TYPE: str = "B77W"
    N_ENGINES: int = 4
    WINGSPAN: float = 60.920
    STARTING_WEIGHT: float = 240000
    NOMINAL_ENGINE_EFFICIENCY: float = 0.33
    NOMINAL_FUEL_FLOW: float = 1.8

    # Search Constraints
    FLIGHT_LEVELS: list[int] = [310, 330, 350, 370, 390]
    PRESSURE_LEVELS: list[int] = [300, 250, 200]
    STARTING_ALTITUDE: float = 31000
    INITIAL_THRUST: float = 0.84
    MAX_THRUST_VAR: float = 0.01
    MAX_THRUST: float = 0.84
    NOMINAL_THRUST: float = 0.84
    MAX_ALTITUDE: int = 39000
    MAX_ALTITUDE_VAR: int = 4000
    ALTITUDE_STEP: int = 2000
    OFFSET_VAR: int = 20

    # Objective Functions
    OBJECTIVES: list["Objective"] = [ContrailObjective, CO2Objective, TimeObjective]

    # Earth radius in km
    R: int = 6371


# Uses gridded CoCiP data
class ContrailConfig(Config):
    NAME: str = "contrail"
    OBJECTIVES: list["Objective"] = [ContrailObjective]
    CONTRAIL_WEIGHT: float = 1


class CocipConfig(Config):
    NAME: str = "cocip"
    OBJECTIVES: list["Objective"] = [CocipObjective, CO2Objective, TimeObjective]
    CONTRAIL_WEIGHT: float = 1


class CO2Config(Config):
    NAME: str = "co2"
    OBJECTIVES: list["Objective"] = [CO2Objective]
    CO2_WEIGHT: float = 1


class TimeConfig(Config):
    NAME: str = "time"
    OBJECTIVES: list["Objective"] = [TimeObjective]
    TIME_WEIGHT: float = 1


class ContrailMaxConfig(Config):
    NAME: str = "contrail_max"
    OBJECTIVES: list["Objective"] = [ContrailObjective]
    CONTRAIL_WEIGHT: float = -10

\end{minted}
\subsection{pdf.py}
\begin{minted}[breaklines,fontsize=\small]{python}
import os


def convert_to_tex(directory, output_tex):
    with open(output_tex, "w", encoding="utf-8") as tex_file:
        for root, dirs, _ in os.walk(directory):
            # Skip .venv and __pycache__ directories
            if ".venv" in dirs:
                dirs.remove(".venv")
            if "__pycache__" in dirs:
                dirs.remove("__pycache__")
            if ".git" in dirs:
                dirs.remove(".git")

            # Write a section for the current directory
            current_dir = os.path.relpath(root, directory)
            if current_dir != "." and "tests" not in current_dir:
                tex_file.write(r"\section{" + current_dir + r"}" + "\n")

            # Include Python files within the current directory
            for filename in os.listdir(root):
                if filename.endswith(".py"):
                    filepath = os.path.join(root, filename)
                    tex_file.write(r"\subsection{" + filename + r"}" + "\n")
                    with open(filepath, "r", encoding="utf-8") as file:
                        code = file.read()
                        tex_file.write(
                            r"\begin{minted}[breaklines,fontsize=\small]{python}" + "\n"
                        )
                        tex_file.write(code + "\n")
                        tex_file.write(r"\end{minted}" + "\n")

            # Include Python files from tests folders within the current directory
            tests_dir = os.path.join(root, "tests")
            if os.path.exists(tests_dir):
                tex_file.write(r"\subsection{Tests}" + "\n")
                for filename in os.listdir(tests_dir):
                    if filename.endswith(".py"):
                        filepath = os.path.join(tests_dir, filename)
                        tex_file.write(r"\subsubsection{" + filename + r"}" + "\n")
                        with open(filepath, "r", encoding="utf-8") as file:
                            code = file.read()
                            tex_file.write(
                                r"\begin{minted}[breaklines,fontsize=\small]{python}"
                                + "\n"
                            )
                            tex_file.write(code + "\n")
                            tex_file.write(r"\end{minted}" + "\n")


convert_to_tex(".", "code.tex")

\end{minted}
\subsection{graphs.py}
\begin{minted}[breaklines,fontsize=\small]{python}
from matplotlib.patches import Patch, Circle
import numpy as np
from matplotlib.collections import PolyCollection
import shapely
import json
import pandas as pd


def show_pareto_front(display, pareto_front):
    blank3d = display.blank3d
    _, axs = blank3d.create_fig(1, 1)
    pareto_front = [flight.objectives for flight in pareto_front]
    pareto_front = pd.DataFrame(pareto_front)

    blank3d.show_front(pareto_front, axs[0])


def compare_fronts(display, fronts):
    blank3d = display.blank3d
    _, axs = blank3d.create_fig(1, 1)

    blank3d.compare_fronts(fronts, axs[0])


def show_objectives_over_time(display, objectives):
    blank = display.blank
    _, objective_axs = blank.create_fig(3, 1)
    objectives = pd.DataFrame(objectives)

    # Show objectives over time
    blank.show_plot(
        objectives["contrail"],
        objective_axs[0],
        color="b",
        title="Lowest contrail EF over iterations",
        x_label="Iteration",
        y_label="EF",
    )
    blank.show_plot(
        objectives["co2"],
        objective_axs[1],
        color="r",
        title="Least kg of CO2 over iterations",
        x_label="Iteration",
        y_label="kg of CO2",
    )
    blank.show_plot(
        objectives["time"],
        objective_axs[2],
        color="g",
        title="Shortest time over iterations",
        x_label="Iteration",
        y_label="Time (s)",
    )


def show_flight_frames(
    display, real_flight_df, aco_path, random_path_df, contrail_grid, config
):
    maps = display.maps
    fig, map_axs = maps.create_fig(2, 2)

    fig.tight_layout()

    time = aco_path["time"].min()
    aco_cutoff_df = get_path_before_time(aco_path, time)

    legend_patches = [
        Patch(color="blue", label="BA177 Flight Path"),
        Patch(color="green", label="Random Flight Path"),
        Patch(color="red", label="ACO Flight Path"),
    ]

    timestamps = contrail_grid["time"]
    fig.legend(handles=legend_patches)

    for ax in map_axs:
        flight_duration = real_flight_df["time"].max() - real_flight_df["time"].min()
        time_step = flight_duration / len(map_axs)
        time = time + pd.Timedelta(time_step)

        aco_cutoff_df = get_path_before_time(aco_path, time)
        random_cutoff_df = get_path_before_time(random_path_df, time)
        real_cutoff_df = get_path_before_time(real_flight_df, time)
        maps.show_path(real_cutoff_df, ax, color="blue", linewidth=2)
        maps.show_path(random_cutoff_df, ax, color="green", linewidth=2)
        maps.show_path(aco_cutoff_df, ax, color="red", linewidth=2)
        ax.set_title("Time: {}".format(time))
        #
        # Interpolate contrail grid data at the given timestamp
        nearest_timestamp_index = np.argmin(
            np.abs(timestamps - np.datetime64(time)).values
        )
        nearest_flight_level_index = np.argmin(
            np.abs(config.FLIGHT_LEVELS - (aco_cutoff_df["altitude_ft"].iloc[-1] / 100))
        )
        interpolated_grid = contrail_grid.isel(
            flight_level=nearest_flight_level_index, time=nearest_timestamp_index
        )
        plot = maps.show_contrail_grid(interpolated_grid, ax)
    cbar = fig.colorbar(
        plot,
        ax=map_axs,
        cmap="coolwarm",
        orientation="horizontal",
        shrink=0.5,
    )
    cbar.set_label("Contrail EF")
    fig.suptitle("Flight paths over time", fontsize=16)

    return fig


def get_path_before_time(path, time):
    time = pd.Timestamp(time)
    return path[path["time"] <= time]


def show_3d_flight_frames(
    display,
    real_flight_df,
    aco_path,
    random_path_df,
    contrail_polys,
    contrail_grid,
    config,
):
    def get_contrail_polys_at_time(contrail_polys, time):
        collections = {}
        polys = contrail_polys["polys"]
        for level in config.FLIGHT_LEVELS:
            patches = []
            for poly in polys:
                if (
                    poly["properties"]["level"] == level
                    and poly["properties"]["time"] == time
                ):
                    multipoly = shapely.from_geojson(json.dumps(poly))
                    for geom in multipoly.geoms:
                        geom = geom.simplify(0.3)
                        x, y = geom.exterior.coords.xy
                        patches.append(np.asarray(tuple(zip(x, y))))
            collection = PolyCollection(patches, facecolor="red", alpha=0.3)
            collections[level] = collection

        return collections

    def convert_time_string(time):
        new_time_str = np.datetime_as_string(time, unit="s") + "Z"
        return new_time_str

    maps = display.maps3d
    fig, map_axs = maps.create_fig(2, 2)

    fig.set_figwidth(10)
    fig.set_figheight(8)

    time = aco_path["time"].min()
    aco_cutoff_df = get_path_before_time(aco_path, time)

    legend_patches = [
        Patch(color="blue", label="BA177 Flight Path"),
        Patch(color="green", label="Random Flight Path"),
        Patch(color="red", label="ACO Flight Path"),
        Circle(xy=(0, 0), color="red", label="Contrail", alpha=0.3, radius=0.1),
    ]

    fig.legend(handles=legend_patches)

    for ax in map_axs:
        flight_duration = real_flight_df["time"].max() - real_flight_df["time"].min()
        time_step = flight_duration / len(map_axs)
        time = time + pd.Timedelta(time_step)

        aco_cutoff_df = get_path_before_time(aco_path, time)
        random_cutoff_df = get_path_before_time(random_path_df, time)
        real_cutoff_df = get_path_before_time(real_flight_df, time)
        maps.show_3d_path(real_cutoff_df, ax, color="blue", linewidth=2)
        maps.show_3d_path(random_cutoff_df, ax, color="green", linewidth=2)
        maps.show_3d_path(aco_cutoff_df, ax, color="red", linewidth=2)
        ax.set_title("Time: {}".format(time))

        timestamps = contrail_grid["time"]

        # Interpolate contrail grid data at the given timestamp
        nearest_timestamp_index = np.argmin(
            np.abs(timestamps - np.datetime64(time)).values
        )
        time_string = convert_time_string(
            contrail_grid["time"][nearest_timestamp_index].values
        )
        # Interpolate contrail grid data at the given timestamp
        polys_at_time = get_contrail_polys_at_time(contrail_polys, time_string)
        for level in polys_at_time:
            ax.add_collection3d(polys_at_time[level], zs=level * 100, zdir="z")

    fig.suptitle("3D Flight paths over time", fontsize=16)
    return fig


def show_flight_path_comparison(
    display,
    geodesic_path,
    real_flight_df,
    chosen_pareto_path_df,
    random_path_df,
    pareto_set,
    fp_cocip,
    aco_cocip,
    rand_cocip,
):
    maps = display.maps
    fig, map_axs = maps.create_fig(3, 1)
    fig.set_figwidth(14)
    fig.set_figheight(5)
    fig.tight_layout()

    fig.title = "Flight Path Comparison"

    maps.show_path(geodesic_path, map_axs[0], color="k", linestyle="--")
    maps.show_path(real_flight_df, map_axs[0], color="blue", linewidth=2)
    maps.set_title(map_axs[0], "BA177 Flight Path - Jan 31 2024")

    maps.show_path(geodesic_path, map_axs[1], color="k", linestyle="--")
    maps.show_path(random_path_df, map_axs[1], color="green", linewidth=2)
    maps.set_title(map_axs[1], "Random Flight Path")

    maps.show_path(geodesic_path, map_axs[2], color="k", linestyle="--")

    for ant_path in pareto_set:
        path_df = pd.DataFrame(ant_path.flight_path, columns=["latitude", "longitude"])
        maps.show_path(path_df, map_axs[2], color="gray", linewidth=0.5)

    maps.show_path(chosen_pareto_path_df, map_axs[2], color="red", linewidth=2)
    maps.set_title(map_axs[2], "ACO Flight Path")

    maps.show_contrails(fp_cocip, map_axs[0])
    maps.show_contrails(rand_cocip, map_axs[1])
    plot = maps.show_contrails(aco_cocip, map_axs[2])
    cbar = fig.colorbar(
        plot,
        ax=map_axs,
        cmap="coolwarm",
        orientation="horizontal",
        shrink=0.3,
    )
    cbar.set_label("Contrail EF")
    fig.suptitle("Contrail lifetimes for different flight paths", fontsize=16)

    return fig

\end{minted}
\subsection{main.py}
\begin{minted}[breaklines,fontsize=\small]{python}
from __future__ import print_function, unicode_literals
import random
from pymoo.indicators.hv import HV
from pymoo.indicators import distance_indicator
from pymoo.util.normalization import ZeroToOneNormalization
import numpy as np
import warnings
from dotenv import load_dotenv
import pandas as pd
import typer
from rich import print
from rich.progress import Progress, SpinnerColumn, TextColumn
from rich.table import Table
import inquirer
import pickle
from pathlib import Path
import os
import graphs
from config import (
    Config,
    ContrailMaxConfig,
    ContrailConfig,
    CO2Config,
    TimeConfig,
    CocipConfig,
)
from objectives import ContrailObjective, CO2Objective, TimeObjective, CocipObjective
from routing_graph import RoutingGraphManager
from performance_model import PerformanceModel, RealFlight, RandomFlight
from aco import ACO
from display import Display


def load_pickle(file_path):
    with open(file_path, "rb") as f:
        return pickle.load(f)


def save_pickle(file_path, data):
    Path(os.path.dirname(file_path)).mkdir(parents=True, exist_ok=True)
    with open(file_path, "wb") as f:
        pickle.dump(data, f)


def load_csv(file_path):
    return pd.read_csv(file_path)


def save_csv(file_path, data):
    Path(os.path.dirname(file_path)).mkdir(parents=True, exist_ok=True)
    data.to_csv(file_path, index=False)


def print_results_table(real_flight, random_flight, pareto_set, chosen_pareto_path):
    real_flight_objectives = real_flight.objectives
    random_flight_objectives = random_flight.objectives

    table = Table()
    table.add_column("Solution", style="bold")
    table.add_column("Contrail EF", style="blue italic")
    table.add_column("kg of CO2", style="red italic")
    table.add_column("Time (h)", style="green italic")
    table.add_column("CoCiP EF", style="yellow italic")
    table.add_row(
        "[blue]Real Flight[/blue]",
        "{:.3g}".format(real_flight_objectives["contrail"]),
        "{:.3g}".format(real_flight_objectives["co2"]),
        "{:.3g}".format(real_flight_objectives["time"]),
        "{:.3g}".format(real_flight_objectives["cocip"]),
    )
    table.add_row(
        "[green]Rand. Flight[/green]",
        "{:.3g}".format(random_flight_objectives["contrail"]),
        "{:.3g}".format(random_flight_objectives["co2"]),
        "{:.3g}".format(random_flight_objectives["time"]),
        "{:.3g}".format(random_flight_objectives["cocip"]),
    )
    for i, solution in enumerate(pareto_set):
        name = f"Solution {i + 1}"
        if chosen_pareto_path is not None:
            if solution.flight_path == chosen_pareto_path.flight_path:
                name = "[red]Chosen Path[/red]"
        table.add_row(
            name,
            "{:.3g}".format(solution.objectives["contrail"]),
            "{:.3g}".format(solution.objectives["co2"]),
            "{:.3g}".format(solution.objectives["time"]),
            "{:.3g}".format(solution.objectives["cocip"]),
        )

    print(table)
    # Add some space between the table and the next question, as it'll get cut off by inquirer
    print("\n \n \n")


def run_aco(config: Config, choose_path=False):
    with Progress(
        SpinnerColumn(),
        TextColumn("[progress.description]{task.description}"),
        transient=True,
    ) as progress:
        progress.add_task(description="Creating altitude grid...", total=None)
        routing_graph_manager = RoutingGraphManager(config)
        geodesic_path = routing_graph_manager.get_geodesic_path()
    print("[bold green]:white_check_mark: Altitude grid constructed.[/bold green]")

    # Construct performance model
    with Progress(
        SpinnerColumn(),
        TextColumn("[progress.description]{task.description}"),
        transient=True,
    ) as progress:
        progress.add_task(description="Creating performance model...", total=None)
        performance_model = PerformanceModel(routing_graph_manager, config)
        contrail_grid = performance_model.get_contrail_grid()
        contrail_polys = performance_model.get_contrail_polys()
        cocip_manager = performance_model.get_cocip_manager()
        routing_graph_manager.set_performance_model(performance_model)
    print("[bold green]:white_check_mark: Performance model constructed.[/bold green]")

    _ = routing_graph_manager.get_routing_graph()

    # Run ACO
    ant_colony = ACO(routing_graph_manager, config)
    pareto_set = ant_colony.run_aco_colony()
    objectives = ant_colony.objectives_over_time
    print("[bold green]:white_check_mark: ACO complete.[/bold green]")

    # Run performance model on a real flight
    with Progress(
        SpinnerColumn(),
        TextColumn("[progress.description]{task.description}"),
        transient=True,
    ) as progress:
        progress.add_task(
            description="Running performance model on real flight...", total=None
        )
        real_flight = RealFlight("jan-31-cleaned.csv", routing_graph_manager, config)
        real_flight.run_performance_model()
    print(
        "[bold green]:white_check_mark: Performance model run on real flight.[/bold green]"
    )

    with Progress(
        SpinnerColumn(),
        TextColumn("[progress.description]{task.description}"),
        transient=True,
    ) as progress:
        progress.add_task(description="Creating a random flight path...", total=None)
        random_flight_path = RandomFlight(routing_graph_manager, config)
        random_flight_path.construct_random_flight()
        random_flight_path.run_performance_model()
    print("[bold green]:white_check_mark: Created a random flight path.[/bold green]")

    with Progress(
        SpinnerColumn(),
        TextColumn("[progress.description]{task.description}"),
        transient=True,
    ) as progress:
        progress.add_task(description="Recalculating objectives...", total=None)
        # Recalculate objectives
        objective_list = [
            ContrailObjective,
            CO2Objective,
            TimeObjective,
            CocipObjective,
        ]
        config.OBJECTIVES = objective_list

        random_flight_path.config = config
        real_flight.config = config
        random_flight_path.calculate_objectives()
        real_flight.calculate_objectives()
        for path in pareto_set:
            path.config = config
            path.calculate_objectives()

    print_results_table(real_flight, random_flight_path, pareto_set, None)

    if choose_path:
        questions = [
            inquirer.List(
                "results",
                message="What path would you like to choose?",
                choices=[i + 1 for i, _ in enumerate(pareto_set)],
                carousel=True,
            )
        ]
        answers = inquirer.prompt(questions)
        chosen_pareto_path = pareto_set[answers["results"] - 1]
    else:
        chosen_pareto_path = random.choice(pareto_set)

    # Calculate CoCiP for both paths
    with Progress(
        SpinnerColumn(),
        TextColumn("[progress.description]{task.description}"),
        transient=True,
    ) as progress:
        progress.add_task(description="Running CoCiP for both flights...", total=None)
        fp_ef, fp_df, fp_cocip = cocip_manager.calculate_ef_from_flight_path(
            real_flight.flight_path
        )
        aco_ef, aco_df, aco_cocip = cocip_manager.calculate_ef_from_flight_path(
            chosen_pareto_path.flight_path
        )
        rand_ef, rand_df, rand_cocip = cocip_manager.calculate_ef_from_flight_path(
            random_flight_path.flight_path
        )
    print(
        "[bold green]:white_check_mark: CoCiP calculated for both flights.[/bold green]"
    )

    return (
        geodesic_path,
        real_flight,
        random_flight_path,
        chosen_pareto_path,
        pareto_set,
        objectives,
        fp_cocip,
        aco_cocip,
        rand_cocip,
        contrail_grid,
        contrail_polys,
    )


def save_results(dir: str, results, config):
    (
        geodesic_path,
        real_flight,
        random_flight_path,
        chosen_pareto_path,
        pareto_set,
        objectives,
        fp_cocip,
        aco_cocip,
        rand_cocip,
        contrail_grid,
        contrail_polys,
    ) = results
    save_pickle(f"{dir}geodesic_path.pkl", geodesic_path)
    save_pickle(f"{dir}real_flight.pkl", real_flight)
    save_pickle(f"{dir}chosen_pareto_path.pkl", chosen_pareto_path)
    save_pickle(f"{dir}random_flight.pkl", random_flight_path)
    save_pickle(f"{dir}pareto_set.pkl", pareto_set)
    save_pickle(f"{dir}fp_cocip.pkl", fp_cocip)
    save_pickle(f"{dir}aco_cocip.pkl", aco_cocip)
    save_pickle(f"{dir}rand_cocip.pkl", rand_cocip)
    save_pickle(f"{dir}contrail_grid.pkl", contrail_grid)
    save_pickle(f"{dir}contrail_polys.pkl", contrail_polys)
    save_pickle(f"{dir}config.pkl", config)
    save_csv(f"{dir}objectives.csv", pd.DataFrame(objectives))
    save_csv(
        f"{dir}real_flight_objectives.csv",
        pd.DataFrame(real_flight.objectives, index=[0]),
    )
    pareto_set_objectives = [solution.objectives for solution in pareto_set]
    save_csv(
        f"{dir}pareto_set_objectives.csv",
        pd.DataFrame(pareto_set_objectives),
    )
    save_csv(
        f"{dir}random_objectives.csv",
        pd.DataFrame(random_flight_path.objectives, index=[0]),
    )


def load_results(dir: str):
    geodesic_path = load_pickle(f"{dir}geodesic_path.pkl")
    real_flight = load_pickle(f"{dir}real_flight.pkl")
    chosen_pareto_path = load_pickle(f"{dir}chosen_pareto_path.pkl")
    random_flight_path = load_pickle(f"{dir}random_flight.pkl")
    pareto_set = load_pickle(f"{dir}pareto_set.pkl")
    objectives = load_csv(f"{dir}objectives.csv")
    fp_cocip = load_pickle(f"{dir}fp_cocip.pkl")
    aco_cocip = load_pickle(f"{dir}aco_cocip.pkl")
    rand_cocip = load_pickle(f"{dir}rand_cocip.pkl")
    contrail_grid = load_pickle(f"{dir}contrail_grid.pkl")
    contrail_polys = load_pickle(f"{dir}contrail_polys.pkl")
    config = load_pickle(f"{dir}config.pkl")

    return (
        geodesic_path,
        real_flight,
        random_flight_path,
        chosen_pareto_path,
        pareto_set,
        objectives,
        fp_cocip,
        aco_cocip,
        rand_cocip,
        contrail_grid,
        contrail_polys,
        config,
    )


def save_figs(dir: str, results, config):
    display = Display()
    (
        geodesic_path,
        real_flight,
        random_flight_path,
        chosen_pareto_path,
        pareto_set,
        objectives,
        fp_cocip,
        aco_cocip,
        rand_cocip,
        contrail_grid,
        contrail_polys,
    ) = results
    geodesic_path = pd.DataFrame(geodesic_path, columns=["latitude", "longitude"])
    real_flight_df = pd.DataFrame(
        real_flight.flight_path,
        columns=["latitude", "longitude", "time", "altitude_ft"],
    )
    chosen_pareto_path_df = pd.DataFrame(
        chosen_pareto_path.flight_path,
        columns=["latitude", "longitude", "time", "altitude_ft"],
    )
    random_path_df = pd.DataFrame(
        random_flight_path.flight_path,
        columns=["latitude", "longitude", "time", "altitude_ft"],
    )
    fig1 = graphs.show_flight_path_comparison(
        display,
        geodesic_path,
        real_flight_df,
        chosen_pareto_path_df,
        random_path_df,
        pareto_set,
        fp_cocip,
        aco_cocip,
        rand_cocip,
    )

    fig2 = graphs.show_flight_frames(
        display,
        real_flight_df,
        chosen_pareto_path_df,
        random_path_df,
        contrail_grid.contrail_grid,
        config,
    )

    fig3 = graphs.show_3d_flight_frames(
        display,
        real_flight_df,
        chosen_pareto_path_df,
        random_path_df,
        contrail_polys,
        contrail_grid.contrail_grid,
        config,
    )
    Path(dir).mkdir(parents=True, exist_ok=True)

    fig1.savefig(f"{dir}flight_path_comparison.png", dpi=300)
    fig2.savefig(f"{dir}flight_frames.png", dpi=300)
    fig3.savefig(f"{dir}3d_flight_frames.png", dpi=300)


def result_run(config, dir: str):
    # Construct all required grids + models
    results = run_aco(config)

    save_results(f"{dir}pickles/", results, config)
    save_figs(f"{dir}figs/", results, config)


def automate_results():
    configs = [
        Config(),
        ContrailConfig(),
        CO2Config(),
        TimeConfig(),
    ]
    iterations = [1, 10, 50, 100, 200]
    evaporation_rates = [0.2, 0.5, 0.8]
    no_of_ants = [1, 8, 16]
    constants = {
        "no_of_iterations": 100,
        "evaporation_rate": 0.5,
        "no_of_ants": 8,
    }
    questions = [
        inquirer.Checkbox(
            "results",
            message="What results would you like to collect?",
            choices=[
                "Iterations",
                "Configs",
                "Evaporation rates",
                "No of ants",
            ],
            carousel=True,
        )
    ]
    answers = inquirer.prompt(questions)

    if "Iterations" in answers["results"]:
        print("[bold blue]Collecting iterations data...[/bold blue]")
        for iteration in iterations:
            print(f"[blue]Running {iteration} iterations...[/blue]")
            config = Config()
            config.NO_OF_ITERATIONS = iteration
            config.EVAPORATION_RATE = constants["evaporation_rate"]
            config.NO_OF_ANTS = constants["no_of_ants"]
            result_run(config, f"results/iterations/{iteration}/")

    if "Configs" in answers["results"]:
        print("[bold blue]Collecting configs data...[/bold blue]")
        for config in configs:
            print(f"[blue]Running {config.NAME}...[/blue]")
            config.NO_OF_ITERATIONS = constants["no_of_iterations"]
            config.EVAPORATION_RATE = constants["evaporation_rate"]
            config.NO_OF_ANTS = constants["no_of_ants"]
            result_run(config, f"results/configs/{config.NAME}/")

    if "Evaporation rates" in answers["results"]:
        print("[bold blue]Collecting evaporation rates data...[/bold blue]")
        for evaporation_rate in evaporation_rates:
            print(f"[blue]Running {evaporation_rate} evaporation rate...[/blue]")
            config = Config()
            config.EVAPORATION_RATE = evaporation_rate
            config.NO_OF_ITERATIONS = constants["no_of_iterations"]
            config.NO_OF_ANTS = constants["no_of_ants"]
            result_run(config, f"results/evaporation_rates/{evaporation_rate}/")

    if "No of ants" in answers["results"]:
        print("[bold blue]Collecting no of ants data...[/bold blue]")
        for no_of_ant in no_of_ants:
            if no_of_ant != 16:
                continue
            print(f"[blue]Running {no_of_ant} ants...[/blue]")
            config = Config()
            config.NO_OF_ANTS = no_of_ant
            config.NO_OF_ITERATIONS = constants["no_of_iterations"]
            config.EVAPORATION_RATE = constants["evaporation_rate"]
            result_run(config, f"results/no_of_ants/{no_of_ant}/")

    print("[bold green]:white_check_mark: Results collected.[/bold green]")


def compare_fronts():
    questions = [
        inquirer.Path(
            "dir",
            message="Where are the fronts located?",
            default="results/user/",
            path_type=inquirer.Path.DIRECTORY,
        ),
    ]
    answers = inquirer.prompt(questions)
    dfs = []

    # Load all CSVs in the directory
    for filename in os.listdir(answers["dir"]):
        if filename.endswith(".csv"):
            filepath = os.path.join(answers["dir"], filename)
            df = pd.read_csv(filepath)
            df.name = os.path.splitext(filename)[0]
            dfs.append(df)

    display = Display()
    concat_dfs = pd.concat(dfs).values
    ideal, nadir = distance_indicator.derive_ideal_and_nadir_from_pf(concat_dfs)
    normalization = ZeroToOneNormalization(ideal, nadir)

    # Normalise all dataframes
    norm_dfs = []
    for df in dfs:
        norm_df = pd.DataFrame(normalization.forward(df.values), columns=df.columns)
        norm_df.name = df.name
        norm_dfs.append(norm_df)

    graphs.compare_fronts(display, norm_dfs)
    concat_dfs = pd.concat(norm_dfs).values

    # Create a hypervolume from the normalised dataframes
    hv = HV(ref_point=np.max(concat_dfs, axis=0) + 0.1)
    for front in norm_dfs:
        hypervolume = hv(front.values)
        print(f"HV {front.name}: {hypervolume}")

    display.show()


def main():
    questions = [
        inquirer.List(
            "choice",
            message="What would you like to do?",
            choices=[
                "Run ACO",
                "Load ACO Results",
                "Automate Results",
                "Compare Pareto Fronts",
            ],
            carousel=True,
        ),
    ]

    answers = inquirer.prompt(questions)

    if answers["choice"] == "Automate Results":
        automate_results()
        print("[bold green]:white_check_mark: Results automated.[/bold green]")
        return

    elif answers["choice"] == "Compare Pareto Fronts":
        compare_fronts()
        return
    elif answers["choice"] == "Load ACO Results":
        questions = [
            inquirer.Path(
                "dir",
                message="Where are the results located?",
                default="results/user/",
                path_type=inquirer.Path.DIRECTORY,
            ),
        ]
        answers = inquirer.prompt(questions)
        with Progress(
            SpinnerColumn(),
            TextColumn("[progress.description]{task.description}"),
            transient=True,
        ) as progress:
            progress.add_task(description="Loading results...", total=None)
            results = load_results(answers["dir"])
            (
                geodesic_path,
                real_flight,
                random_flight_path,
                chosen_pareto_path,
                pareto_set,
                objectives,
                fp_cocip,
                aco_cocip,
                rand_cocip,
                contrail_grid,
                contrail_polys,
                config,
            ) = results

            print_results_table(
                real_flight,
                random_flight_path,
                pareto_set,
                chosen_pareto_path,
            )

        print("[bold green]:white_check_mark: Results loaded.[/bold green]")
        questions = [
            inquirer.Confirm(
                "choose_path",
                message="Would you like to choose a different path?",
                default=False,
            ),
        ]
        answers = inquirer.prompt(questions)

        if answers["choose_path"] is True:
            questions = [
                inquirer.List(
                    "results",
                    message="What path would you like to choose?",
                    choices=[i + 1 for i, _ in enumerate(pareto_set)],
                    carousel=True,
                )
            ]
            answers = inquirer.prompt(questions)
            chosen_pareto_path = pareto_set[answers["results"] - 1]
            # A bit of a hack to recalculate CoCiP for the new chosen path
            _, _, aco_cocip = (
                chosen_pareto_path.performance_model.cocip_manager.calculate_ef_from_flight_path(
                    chosen_pareto_path.flight_path
                )
            )

    else:
        questions = [
            inquirer.List(
                "config",
                message="Which configuration would you like to use?",
                choices=["Default", "ContrailMax", "Contrail", "CO2", "Time", "CoCiP"],
                carousel=True,
            ),
            inquirer.List(
                "iterations",
                message="How many iterations would you like to run?",
                choices=[1, 10, 50, 100, 200],
                carousel=True,
            ),
            inquirer.List(
                "evaporation_rate",
                message="Choose an evaporation rate.",
                choices=[0.2, 0.5, 0.8],
                carousel=True,
            ),
            inquirer.List(
                "no_of_ants",
                message="Choose a number of ants.",
                choices=[1, 8, 16],
                carousel=True,
            ),
        ]
        answers = inquirer.prompt(questions)
        if answers["config"] == "Default":
            config = Config()
        elif answers["config"] == "Contrail":
            config = ContrailConfig()
        elif answers["config"] == "CO2":
            config = CO2Config()
        elif answers["config"] == "Time":
            config = TimeConfig()
        elif answers["config"] == "CoCiP":
            config = CocipConfig()
        else:
            config = ContrailMaxConfig()

        config.NO_OF_ITERATIONS = answers["iterations"]
        config.EVAPORATION_RATE = answers["evaporation_rate"]
        config.NO_OF_ANTS = answers["no_of_ants"]

        # Construct all required grids + models
        results = run_aco(config, choose_path=True)
        (
            geodesic_path,
            real_flight,
            random_flight_path,
            chosen_pareto_path,
            pareto_set,
            objectives,
            fp_cocip,
            aco_cocip,
            rand_cocip,
            contrail_grid,
            contrail_polys,
        ) = results

        questions = [
            inquirer.Confirm(
                "save",
                message="Would you like to save the results?",
                default=True,
            ),
        ]
        answers = inquirer.prompt(questions)
        if answers["save"]:
            questions = [
                inquirer.Path(
                    "dir",
                    message="Where would you like to save the results?",
                    default="results/user/",
                    path_type=inquirer.Path.DIRECTORY,
                ),
            ]
            answers = inquirer.prompt(questions)
            with Progress(
                SpinnerColumn(),
                TextColumn("[progress.description]{task.description}"),
                transient=True,
            ) as progress:
                progress.add_task(
                    description="Saving results...",
                    total=None,
                )
                save_results(answers["dir"], results, config)

            print("[bold green]:white_check_mark: Results saved.[/bold green]")

    geodesic_path = pd.DataFrame(geodesic_path, columns=["latitude", "longitude"])
    real_flight_df = pd.DataFrame(
        real_flight.flight_path,
        columns=["latitude", "longitude", "time", "altitude_ft"],
    )
    chosen_pareto_path_df = pd.DataFrame(
        chosen_pareto_path.flight_path,
        columns=["latitude", "longitude", "time", "altitude_ft"],
    )
    random_path_df = pd.DataFrame(
        random_flight_path.flight_path,
        columns=["latitude", "longitude", "time", "altitude_ft"],
    )

    questions = [
        inquirer.Checkbox(
            "graphs",
            message="What plots would you like to see?",
            choices=[
                "Objectives over time",
                "Flight path comparison",
                "Flight path over time",
                "3D Flight path over time",
                "Pareto Front",
            ],
            carousel=True,
        ),
    ]
    answers = inquirer.prompt(questions)

    # Display results
    display = Display()

    if "Objectives over time" in answers["graphs"]:
        graphs.show_objectives_over_time(display, objectives)

    if "Flight path comparison" in answers["graphs"]:
        graphs.show_flight_path_comparison(
            display,
            geodesic_path,
            real_flight_df,
            chosen_pareto_path_df,
            random_path_df,
            pareto_set,
            fp_cocip,
            aco_cocip,
            rand_cocip,
        )

    if "Pareto Front" in answers["graphs"]:
        graphs.show_pareto_front(display, pareto_set)

    if "Flight path over time" in answers["graphs"]:
        graphs.show_flight_frames(
            display,
            real_flight_df,
            chosen_pareto_path_df,
            random_path_df,
            contrail_grid.contrail_grid,
            config,
        )

    if "3D Flight path over time" in answers["graphs"]:
        graphs.show_3d_flight_frames(
            display,
            real_flight_df,
            chosen_pareto_path_df,
            random_path_df,
            contrail_polys,
            contrail_grid.contrail_grid,
            config,
        )

    display.show()


if __name__ == "__main__":
    app = typer.Typer()
    load_dotenv()
    warnings.filterwarnings("ignore")
    typer.run(main)

\end{minted}
\section{aco}
\subsection{ant.py}
\begin{minted}[breaklines,fontsize=\small]{python}
import random
import math
from performance_model import Flight

import typing

if typing.TYPE_CHECKING:
    from config import Config
    from routing_graph import RoutingGraphManager, RoutingGraph
    from _types import FlightPath, Objectives, IndexPoint3D


class Ant:
    def __init__(
        self,
        routing_graph_manager: "RoutingGraphManager",
        objectives: "Objectives",
        config: "Config",
    ):
        """
        A single ant during the ACO algorithm, containing relevant objective and
        heuristic information
        """
        self.routing_graph_manager: "RoutingGraphManager" = routing_graph_manager
        self.routing_graph: "RoutingGraph" = routing_graph_manager.get_routing_graph()
        self.objectives: "Objectives" = objectives
        self.config: "Config" = config

    def run_ant(self, id: int) -> Flight:
        """
        Runs an iteration of the ant going through the routing graph
        """
        solution = self.construct_solution()
        solution.run_performance_model()
        solution.calculate_objectives()

        return solution

    def construct_solution(self) -> Flight:
        """
        Constructs a solution by traversing the routing graph
        """
        solution = Flight(
            self.routing_graph_manager,
            [],
            self.config,
        )
        solution.set_departure(
            ((0, self.config.GRID_WIDTH, self.config.STARTING_ALTITUDE))
        )

        neighbours = self.routing_graph[solution.indices[0]]
        while neighbours:
            probabilities = []
            choice = None
            random_objective = random.choice(self.objectives)
            for n in neighbours:
                probability = self.calculate_probability_at_neighbour(
                    n,
                    neighbours[n][f"{random_objective}_pheromone"],
                    random_objective,
                )
                if probability is None:
                    # reached the destination
                    choice = n
                    break

                probabilities.append(probability)
            if not choice and probabilities:
                choice = random.choices(list(neighbours), weights=probabilities, k=1)[0]

            solution.add_point_from_index(choice)
            neighbours = self.routing_graph[choice]

        return solution

    def calculate_probability_at_neighbour(
        self,
        node: "IndexPoint3D",
        pheromone: float,
        objective: str,
    ) -> float or None:
        """
        Calculates the probability of an ant choosing this node based off the
        pheromone and heuristic values of its neighbours
        """
        heuristic = self.routing_graph.nodes[node][f"{objective}_heuristic"]
        total_neighbour_factor = 0
        neighbours = self.routing_graph[node]

        alpha = self.config.PHEROMONE_WEIGHT
        beta = self.config.HEURISTIC_WEIGHT
        if node[0] == self.config.NO_OF_POINTS and node[1] == 0:
            return None
        if len(neighbours) == 0:
            return 0.0001
        for n in neighbours:
            total_neighbour_factor += math.pow(
                neighbours[n][f"{objective}_pheromone"], alpha
            ) * math.pow(self.routing_graph.nodes[n][f"{objective}_heuristic"], beta)

        probability = (
            math.pow(pheromone, alpha) * math.pow(heuristic, beta)
        ) / total_neighbour_factor
        return probability

\end{minted}
\subsection{__init__.py}
\begin{minted}[breaklines,fontsize=\small]{python}
from .aco import ACO

\end{minted}
\subsection{aco.py}
\begin{minted}[breaklines,fontsize=\small]{python}
import multiprocessing
from concurrent.futures import ProcessPoolExecutor, as_completed

import networkx as nx
import numpy as np

from .ant import Ant
from rich.progress import track

import typing

if typing.TYPE_CHECKING:
    from config import Config
    from routing_graph import RoutingGraphManager, RoutingGraph
    from types import Objectives
    from objectives import Objective
    from performance_model import Flight


class ACO:
    def __init__(self, routing_graph_manager: "RoutingGraphManager", config: "Config"):
        """
        Class to run the Ant Colony Optimisation algorithm
        """
        self.routing_graph_manager: "RoutingGraphManager" = routing_graph_manager
        self.routing_graph: "RoutingGraph" = routing_graph_manager.get_routing_graph()
        self.config: "Config" = config

        self.objective_functions: list["Objective"] = [
            objective(self.routing_graph_manager.performance_model, self.config)
            for objective in config.OBJECTIVES
        ]
        self.objectives: list[str] = [
            str(objective) for objective in self.objective_functions
        ]
        self.objectives_over_time: list["Objectives"] = []
        self.solutions: list["Flight"] = []
        self.pareto_set: list["Flight"] = []

    def check_pareto_dominance(self, solution: "Flight") -> bool:
        """
        Checks whether a solution belongs in the pareto set
        """
        for existing_solution in self.pareto_set:
            if all(
                solution.objectives[objective]
                >= existing_solution.objectives[objective]
                for objective in self.objectives
            ):
                return True
            elif all(
                solution.objectives[objective]
                <= existing_solution.objectives[objective]
                for objective in self.objectives
            ):
                self.pareto_set.remove(existing_solution)
        return False

    def run_aco_colony(self) -> list["Flight"]:
        """
        Runs the ACO algorithm and generates a pareto front of solutions
        """
        best_objectives = dict.fromkeys(self.objectives, np.inf)
        ants = [
            Ant(
                self.routing_graph_manager,
                self.objective_functions,
                self.config,
            )
            for _ in range(self.config.NO_OF_ANTS)
        ]
        for i in track(range(self.config.NO_OF_ITERATIONS)):
            with ProcessPoolExecutor(
                max_workers=multiprocessing.cpu_count()
            ) as executor:
                # Run the ants
                futures = [
                    executor.submit(ant.run_ant, i) for i, ant in enumerate(ants)
                ]

                iteration_best_solution = dict.fromkeys(self.objectives, None)
                iteration_best_objectives = dict.fromkeys(self.objectives, np.inf)

                # Get the results
                for future in as_completed(futures):
                    solution = future.result()

                    self.solutions.append(solution)
                    # Only add to the pareto set if it is not dominated by any current solution
                    is_dominated = self.check_pareto_dominance(solution)
                    if not is_dominated:
                        self.pareto_set.append(solution)

                    # Track the best objectives for each iteration and globally
                    for objective in self.objective_functions:
                        objective = str(objective)
                        if (
                            solution.objectives[objective]
                            < iteration_best_objectives[objective]
                        ):
                            iteration_best_solution[objective] = solution
                            iteration_best_objectives[objective] = solution.objectives[
                                objective
                            ]

                        if solution.objectives[objective] < best_objectives[objective]:
                            best_objectives[objective] = solution.objectives[objective]

                self.objectives_over_time.append(best_objectives.copy())
                self.pheromone_update(
                    iteration_best_solution, iteration_best_objectives, best_objectives
                )

        return self.pareto_set

    def pheromone_update(
        self,
        solution: "Flight",
        iteration_best_objective: "Objectives",
        best_objective: "Objectives",
    ) -> None:
        """
        Updates the pheromone structure based off the objective values
        """
        evaporation_rate = self.config.EVAPORATION_RATE
        tau_min = self.config.TAU_MIN
        tau_max = self.config.TAU_MAX

        for objective in self.objective_functions:
            objective = str(objective)
            solution_edges = list(nx.utils.pairwise(solution[objective].indices))
            for u, v in solution_edges:
                delta = 0
                edge = self.routing_graph[u][v]
                delta = 1 / max(
                    1, iteration_best_objective[objective] - best_objective[objective]
                )

                new_pheromone = (1 - evaporation_rate) * (
                    edge[f"{objective}_pheromone"] + delta
                )

                self.routing_graph[u][v][f"{objective}_pheromone"] = max(
                    tau_min, min(new_pheromone, tau_max)
                )

\end{minted}
\subsection{Tests}
\subsubsection{test_ant.py}
\begin{minted}[breaklines,fontsize=\small]{python}
import unittest
from unittest.mock import MagicMock
from ..ant import Ant
from performance_model import Flight
import pandas as pd
import networkx as nx


class TestAnt(unittest.TestCase):
    def setUp(self):
        class MockRoutingGraphManager:
            def __init__(self):
                self.routing_graph = MagicMock()
                self.performance_model = MagicMock()

            def get_routing_graph(self):
                return self.routing_graph

            def get_performance_model(self):
                return self.performance_model

            def convert_index_to_point(self, index):
                return {
                    "latitude": 0,
                    "longitude": 0,
                    "altitude_ft": 0,
                    "thrust": 1,
                    "level": 0,
                }

        class MockObjective:
            def __init__(self, performance_model, config):
                self.name = "objective"

            @staticmethod
            def calculate_objective(flight_path):
                return 1

            def _run_objective_function(self, flight_path):
                return 1

        class MockConfig:
            GRID_WIDTH = 0
            STARTING_ALTITUDE = 10000
            NO_OF_POINTS = 3
            PHEROMONE_WEIGHT = 1
            HEURISTIC_WEIGHT = 1
            STARTING_WEIGHT = 100000
            OBJECTIVES = [MockObjective]
            DEPARTURE_DATE = pd.Timestamp(
                year=2024, month=1, day=31, hour=13, minute=45, second=57
            )

        self.mock_routing_graph_manager = MockRoutingGraphManager()
        self.mock_objective = MockObjective
        self.mock_config = MockConfig()

    def test_run_ant(self):
        ant = Ant(
            self.mock_routing_graph_manager, [self.mock_objective], self.mock_config
        )
        ant.construct_solution = MagicMock(
            return_value=Flight(self.mock_routing_graph_manager, [], self.mock_config)
        )
        solution = ant.run_ant(1)
        # Assert that the construct_solution and objective_function methods are called
        ant.construct_solution.assert_called_once()
        self.assertTrue(solution.objectives)  # Check if objectives are set

    def test_construct_solution(self):
        ant = Ant(
            self.mock_routing_graph_manager, [self.mock_objective], self.mock_config
        )
        ant.calculate_probability_at_neighbour = MagicMock(return_value=0.5)
        ant.routing_graph = nx.DiGraph()
        ant.routing_graph.add_node(
            (0, 0, 10000), **{f"{self.mock_objective}_heuristic": 1}
        )
        ant.routing_graph.add_node(
            (0, 1, 10000), **{f"{self.mock_objective}_heuristic": 1}
        )
        ant.routing_graph.add_edge(
            (0, 0, 10000), (0, 1, 10000), **{f"{self.mock_objective}_pheromone": 1}
        )
        solution = ant.construct_solution()
        # Assert that the construct_solution method returns a valid solution
        self.assertTrue(solution.indices)
        self.assertTrue(solution.flight_path)

    def test_calculate_probability_at_neighbour(self):
        ant = Ant(
            self.mock_routing_graph_manager, [self.mock_objective], self.mock_config
        )
        ant.routing_graph = nx.DiGraph()
        ant.routing_graph.add_node(
            (0, 0, 10000), **{f"{self.mock_objective}_heuristic": 1}
        )
        ant.routing_graph.add_node(
            (0, 1, 10000), **{f"{self.mock_objective}_heuristic": 1}
        )
        ant.routing_graph.add_edge(
            (0, 0, 10000), (0, 1, 10000), **{f"{self.mock_objective}_pheromone": 1}
        )
        ant.config.PHEROMONE_WEIGHT = 1
        ant.config.HEURISTIC_WEIGHT = 1
        probability = ant.calculate_probability_at_neighbour(
            (0, 1, 10000), 1, self.mock_objective
        )
        # Assert that the probability is calculated correctly
        self.assertEqual(probability, 0.0001)

\end{minted}
\subsubsection{__init__.py}
\begin{minted}[breaklines,fontsize=\small]{python}

\end{minted}
\subsection{test_ant.py}
\begin{minted}[breaklines,fontsize=\small]{python}
import unittest
from unittest.mock import MagicMock
from ..ant import Ant
from performance_model import Flight
import pandas as pd
import networkx as nx


class TestAnt(unittest.TestCase):
    def setUp(self):
        class MockRoutingGraphManager:
            def __init__(self):
                self.routing_graph = MagicMock()
                self.performance_model = MagicMock()

            def get_routing_graph(self):
                return self.routing_graph

            def get_performance_model(self):
                return self.performance_model

            def convert_index_to_point(self, index):
                return {
                    "latitude": 0,
                    "longitude": 0,
                    "altitude_ft": 0,
                    "thrust": 1,
                    "level": 0,
                }

        class MockObjective:
            def __init__(self, performance_model, config):
                self.name = "objective"

            @staticmethod
            def calculate_objective(flight_path):
                return 1

            def _run_objective_function(self, flight_path):
                return 1

        class MockConfig:
            GRID_WIDTH = 0
            STARTING_ALTITUDE = 10000
            NO_OF_POINTS = 3
            PHEROMONE_WEIGHT = 1
            HEURISTIC_WEIGHT = 1
            STARTING_WEIGHT = 100000
            OBJECTIVES = [MockObjective]
            DEPARTURE_DATE = pd.Timestamp(
                year=2024, month=1, day=31, hour=13, minute=45, second=57
            )

        self.mock_routing_graph_manager = MockRoutingGraphManager()
        self.mock_objective = MockObjective
        self.mock_config = MockConfig()

    def test_run_ant(self):
        ant = Ant(
            self.mock_routing_graph_manager, [self.mock_objective], self.mock_config
        )
        ant.construct_solution = MagicMock(
            return_value=Flight(self.mock_routing_graph_manager, [], self.mock_config)
        )
        solution = ant.run_ant(1)
        # Assert that the construct_solution and objective_function methods are called
        ant.construct_solution.assert_called_once()
        self.assertTrue(solution.objectives)  # Check if objectives are set

    def test_construct_solution(self):
        ant = Ant(
            self.mock_routing_graph_manager, [self.mock_objective], self.mock_config
        )
        ant.calculate_probability_at_neighbour = MagicMock(return_value=0.5)
        ant.routing_graph = nx.DiGraph()
        ant.routing_graph.add_node(
            (0, 0, 10000), **{f"{self.mock_objective}_heuristic": 1}
        )
        ant.routing_graph.add_node(
            (0, 1, 10000), **{f"{self.mock_objective}_heuristic": 1}
        )
        ant.routing_graph.add_edge(
            (0, 0, 10000), (0, 1, 10000), **{f"{self.mock_objective}_pheromone": 1}
        )
        solution = ant.construct_solution()
        # Assert that the construct_solution method returns a valid solution
        self.assertTrue(solution.indices)
        self.assertTrue(solution.flight_path)

    def test_calculate_probability_at_neighbour(self):
        ant = Ant(
            self.mock_routing_graph_manager, [self.mock_objective], self.mock_config
        )
        ant.routing_graph = nx.DiGraph()
        ant.routing_graph.add_node(
            (0, 0, 10000), **{f"{self.mock_objective}_heuristic": 1}
        )
        ant.routing_graph.add_node(
            (0, 1, 10000), **{f"{self.mock_objective}_heuristic": 1}
        )
        ant.routing_graph.add_edge(
            (0, 0, 10000), (0, 1, 10000), **{f"{self.mock_objective}_pheromone": 1}
        )
        ant.config.PHEROMONE_WEIGHT = 1
        ant.config.HEURISTIC_WEIGHT = 1
        probability = ant.calculate_probability_at_neighbour(
            (0, 1, 10000), 1, self.mock_objective
        )
        # Assert that the probability is calculated correctly
        self.assertEqual(probability, 0.0001)

\end{minted}
\subsection{__init__.py}
\begin{minted}[breaklines,fontsize=\small]{python}

\end{minted}
\section{objectives}
\subsection{__init__.py}
\begin{minted}[breaklines,fontsize=\small]{python}
import pandas as pd
from openap import Emission
import geopy.distance as gd
import math
import typing

from performance_model import PerformanceModel

if typing.TYPE_CHECKING:
    from config import Config
    from _types import FlightPath, FlightPoint


class Objective:
    def __init__(self, performance_model: PerformanceModel, config: "Config"):
        """
        Abstract class for objectives
        """
        self.config: "Config" = config
        self.weight: float = 1
        self.performance_model: PerformanceModel = performance_model
        self.name: str or NotImplemented = NotImplemented

    def _run_objective_function(self, flight_path: "FlightPath") -> float:
        """
        Run the objective function on a flight path
        """
        return NotImplemented

    def calculate_objective(self, flight_path: "FlightPath") -> float:
        """
        Runs the objective function and multiplies by the weight
        """
        return self._run_objective_function(flight_path) * self.weight

    def calculate_heuristic(self, flight_path: "FlightPath") -> float:
        return NotImplemented

    def _calculate_time_estimation(self, point: "FlightPoint") -> tuple:
        """
        Calculates a rough time estimation based off an arbitrary speed from the departure to this point
        """
        flat_distance_from_departure = gd.distance(
            (point[0], point[1]),
            self.config.DEPARTURE_AIRPORT,
        ).m
        distance_from_departure = math.sqrt(
            flat_distance_from_departure**2
            + (point[2] - self.config.STARTING_ALTITUDE) ** 2
        )
        speed = (
            self.config.NOMINAL_THRUST * 343
        )  # times by speed of sound for rough speed estimate
        time_to_point = distance_from_departure / speed
        time_at_point = self.config.DEPARTURE_DATE + pd.Timedelta(time_to_point, "s")
        return time_to_point, time_at_point

    def __str__(self) -> str:
        return self.name

    def __repr__(self) -> str:
        return self.name


class ContrailObjective(Objective):
    def __init__(self, performance_model: PerformanceModel, config: "Config"):
        super().__init__(performance_model, config)
        self.name: str = "contrail"
        self.weight: float = config.CONTRAIL_WEIGHT

    def _run_objective_function(self, flight_path: "FlightPath") -> float:
        contrail_ef = self.performance_model.contrail_grid.interpolate_contrail_grid(
            flight_path
        )
        return contrail_ef

    def calculate_heuristic(self, point: "FlightPoint") -> float:
        contrails_at_point = max(
            self.performance_model.contrail_grid.interpolate_contrail_point(point),
            0.01,
        )
        return -contrails_at_point


class CocipObjective(Objective):
    def __init__(self, performance_model: PerformanceModel, config: "Config"):
        super().__init__(performance_model, config)
        self.name: str = "cocip"
        self.weight: float = config.CONTRAIL_WEIGHT

    def _run_objective_function(self, flight_path: "FlightPath") -> float:
        ef, _, _ = self.performance_model.cocip_manager.calculate_ef_from_flight_path(
            flight_path,
        )
        return ef.sum()

    def calculate_heuristic(self, point: "FlightPoint") -> float:
        contrails_at_point = max(
            self.performance_model.contrail_grid.interpolate_contrail_point(point),
            0.01,
        )
        return -contrails_at_point


class CO2Objective(Objective):
    def __init__(self, performance_model: PerformanceModel, config: "Config"):
        super().__init__(performance_model, config)
        self.name: str = "co2"
        self.weight: float = config.CO2_WEIGHT

    def _calculate_flight_duration(self, flight_path: "FlightPath") -> float:
        return (flight_path[-1]["time"] - flight_path[0]["time"]).seconds / 3600

    def _run_objective_function(self, flight_path: "FlightPath") -> float:
        co2_kg = (
            sum(point["CO2"] for point in flight_path)
            * self._calculate_flight_duration(flight_path)
            * 3600
            / 1000  # convert g/s to kg
        )
        return co2_kg

    def calculate_heuristic(self, point: "FlightPoint") -> float:
        time_to_point, time_at_point = self._calculate_time_estimation(point)
        ps_grid = self.performance_model.ps_grid
        point = {
            "latitude": point[0],
            "longitude": point[1],
            "altitude_ft": point[2],
            "time": time_at_point,
        }
        fuel_flow_estimation = ps_grid.get_performance_data_at_point(point)["fuel_flow"]
        co2 = Emission(ac=self.config.AIRCRAFT_TYPE).co2(fuel_flow_estimation)
        return -co2


class TimeObjective(Objective):
    def __init__(self, performance_model: PerformanceModel, config: "Config"):
        super().__init__(performance_model, config)
        self.name: str = "time"
        self.weight: float = config.TIME_WEIGHT

    def _run_objective_function(self, flight_path: "FlightPath") -> float:
        flight_duration = (
            flight_path[-1]["time"] - flight_path[0]["time"]
        ).seconds / 3600
        return flight_duration

    def calculate_heuristic(self, point: "FlightPoint") -> float:
        time_to_point, _ = self._calculate_time_estimation(point)
        return -time_to_point

\end{minted}
\section{utils}
\subsection{kml-to-csv.py}
\begin{minted}[breaklines,fontsize=\small]{python}
import os
import glob
import math
from datetime import datetime
from lxml import etree as ET

# From https://github.com/aleiby/kml2g1000

srcDir = r"data/"


# Returns an array containing the texts of all the specified child nodes of root.
def getAll(root, node):
    return [_.text for _ in root.iterfind(".//" + node, namespaces=root.nsmap)]


# Calculates the groundspeed given two lat/long coordinates and associated start/end datetimes.
def calcSpeed(fm, to, start, end):
    dx = math.hypot(*[b - a for a, b in zip(fm, to)]) * 60.0  # nautical miles
    dt = (end - start).total_seconds() / 3600.0  # hours
    return round(dx / dt) if dt else 0


# Converts a kml tracklog exported from flightaware.com to G1000 csv format.
def export(kml):

    # Skip if already exported
    base = os.path.splitext(kml)[0]
    fileName = base + ".csv"
    if os.path.exists(fileName):
        return

    print("Exporting " + fileName)

    # G1000 header, format, and trailing commas for data we do not set.
    hdr = "DateTime,Latitude,Longitude,AltMSL,GndSpd"
    fmt = "{datetime},{lat},{lng},{alt},{gspd}"

    tree = ET.parse(kml)
    root = tree.getroot()

    # Collect all the timestamps and breadcrumbs.
    whens = getAll(root, "when")
    coords = getAll(root, "gx:coord")

    # Export the csv header.
    csv = [hdr]

    # Export the csv data.
    fm = None
    start = None
    for when, coord in zip(whens, coords):
        # Parse data (e.g. 2022-06-09T15:42:34Z)
        date, time = when.split("T")
        time = time[:-1]  # strip Z
        lng, lat, alt = coord.split(" ")

        # Calculate ground speed.
        # ForeFlight will not accept a G1000 file without valid data here.
        # This is a very rough estimate based on the reported breadcrumbs.
        # FlightAware appears to collect actual data from ADS-B, but does not include it in the kml unfortuantely.
        to = (float(lat), float(lng))
        end = datetime.strptime(date + " " + time, "%Y-%m-%d %H:%M:%S")
        gspd = calcSpeed(fm, to, start, end) if fm and start else 0
        fm = to
        start = end

        # FlightAware KLM altitude is in meters, while G1000 wants feet.
        alt = round(float(alt) * 3.28084)

        # Append data with trailing commas for unset values.
        csv.append(fmt.format(datetime=end, lat=lat, lng=lng, alt=alt, gspd=gspd))

    # Write file to disk.
    with open(fileName, "w") as f:
        f.writelines("\n".join(csv))


# Convert all files in source directory.
files = glob.glob(os.path.join(srcDir, "*.kml"))
for fileName in files:
    export(fileName)

\end{minted}
\subsection{flight-cleaner.py}
\begin{minted}[breaklines,fontsize=\small]{python}
import pandas as pd

from pycontrails import Flight

from datetime import datetime


def convert_real_flight_path(flight_path):
    path = []
    for _, row in flight_path.iterrows():
        time = datetime.strptime(row["DateTime"], "%Y-%m-%d %H:%M:%S")
        path_point = {
            "latitude": row["Latitude"],
            "longitude": row["Longitude"],
            "altitude_ft": row["AltMSL"],
            "thrust": 0.83,
            "time": time,
        }

        path.append(path_point)

    return path


real_flight = pd.read_csv("data/jan-31.csv")
real_flight = real_flight[real_flight["AltMSL"] > 30000]
real_flight = convert_real_flight_path(real_flight)
real_flight = pd.DataFrame(real_flight)
flight = Flight(real_flight)

flight = flight.clean_and_resample(nominal_rocd=4.45)

fl_df = flight.dataframe
# convert altitude to ft
fl_df["altitude_ft"] = fl_df["altitude"] * 3.28084

# save csv
fl_df.to_csv("data/jan-31-cleaned.csv", index=False)

\end{minted}
\subsection{conversions.py}
\begin{minted}[breaklines,fontsize=\small]{python}
class Conversions:
    def __init__(self):
        pass

    # From https://pvlib-python.readthedocs.io/en/v0.2.2/_modules/pvlib/atmosphere.html
    def calculate_altitude_ft_from_pressure(self, pressure):
        pressure_pa = pressure * 100  # Convert to Pa
        # Use the international barometric formula
        altitude = 44331.5 - 4946.62 * pressure_pa ** (0.190263)
        return altitude * 3.28084

    # From https://pvlib-python.readthedocs.io/en/v0.2.2/_modules/pvlib/atmosphere.html
    def calculate_pressure_from_altitude_ft(self, altitude_ft):
        # convert altitude to meters
        altitude_m = altitude_ft / 3.28084
        pressure = ((44331.514 - altitude_m) / 11880.516) ** (1 / 0.1902632)

        return pressure

    def convert_altitude_to_pressure_bounded(
        self, altitude, max_pressure, min_pressure
    ):
        pressure = self.calculate_pressure_from_altitude_ft(altitude)
        return max(max_pressure, min(pressure, min_pressure))

\end{minted}
\subsection{__init__.py}
\begin{minted}[breaklines,fontsize=\small]{python}
from .conversions import Conversions

\end{minted}
\section{results}
\section{results/user2}
\section{results/no_of_ants}
\section{results/no_of_ants/fronts}
\section{results/no_of_ants/16}
\section{results/no_of_ants/16/figs}
\section{results/no_of_ants/16/pickles}
\section{results/no_of_ants/1}
\section{results/no_of_ants/1/figs}
\section{results/no_of_ants/1/pickles}
\section{results/no_of_ants/8}
\section{results/no_of_ants/8/figs}
\section{results/no_of_ants/8/pickles}
\section{results/user}
\section{results/configs}
\section{results/configs/fronts}
\section{results/configs/time}
\section{results/configs/time/figs}
\section{results/configs/time/pickles}
\section{results/configs/contrail}
\section{results/configs/contrail/figs}
\section{results/configs/contrail/pickles}
\section{results/configs/overall}
\section{results/configs/overall/figs}
\section{results/configs/overall/pickles}
\section{results/configs/co2}
\section{results/configs/co2/figs}
\section{results/configs/co2/pickles}
\section{results/evaporation_rates}
\section{results/evaporation_rates/fronts}
\section{results/evaporation_rates/0.5}
\section{results/evaporation_rates/0.5/figs}
\section{results/evaporation_rates/0.5/pickles}
\section{results/evaporation_rates/0.2}
\section{results/evaporation_rates/0.2/figs}
\section{results/evaporation_rates/0.2/pickles}
\section{results/evaporation_rates/0.8}
\section{results/evaporation_rates/0.8/figs}
\section{results/evaporation_rates/0.8/pickles}
\section{results/iterations}
\section{results/iterations/50}
\section{results/iterations/50/figs}
\section{results/iterations/50/pickles}
\section{results/iterations/fronts}
\section{results/iterations/1}
\section{results/iterations/1/figs}
\section{results/iterations/1/pickles}
\section{results/iterations/10}
\section{results/iterations/10/figs}
\section{results/iterations/10/pickles}
\section{results/iterations/100}
\section{results/iterations/100/figs}
\section{results/iterations/100/pickles}
\section{results/iterations/200}
\section{results/iterations/200/figs}
\section{results/iterations/200/pickles}
\section{display}
\subsection{maps.py}
\begin{minted}[breaklines,fontsize=\small]{python}
import cartopy.crs as ccrs
from cartopy.feature import BORDERS, COASTLINE
import matplotlib.pyplot as plt
from matplotlib.collections import LineCollection
from cartopy.mpl.patch import geos_to_path
import itertools
import numpy as np


class Map:
    def __init__(self, crs=None):
        # self.crs = ccrs.NearsidePerspective(central_latitude=51, central_longitude=-35)
        self.crs = ccrs.PlateCarree()

    def create_fig(self, grid_width, grid_height):
        fig = plt.figure(figsize=(10, 8), dpi=100)
        axs = []
        for i in range(1, grid_width * grid_height + 1):
            ax = self._create_map(fig, f"{grid_height}{grid_width}{i}")
            axs.append(ax)
        return fig, axs

    def _create_map(self, fig, grid_pos):
        ax = fig.add_subplot(int(grid_pos), projection=self.crs)
        ax.set_extent([10, -90, 25, 60])
        ax.add_feature(BORDERS, lw=0.5, color="gray")
        ax.gridlines(draw_labels=True, color="gray", alpha=0.5, ls="--")
        ax.coastlines(resolution="50m", lw=0.5, color="gray")
        return ax

    def show_path(self, path, ax, color="green", linewidth=1, linestyle="solid"):
        return ax.plot(
            path["longitude"],
            path["latitude"],
            transform=self.crs,
            color=color,
            linestyle=linestyle,
            linewidth=linewidth,
        )

    def set_title(self, ax, title):
        ax.set_title(title)

    def show_contrails(self, cocip, ax):
        if cocip.contrail is None:
            return

        plot = ax.scatter(
            cocip.contrail["longitude"],
            cocip.contrail["latitude"],
            c=cocip.contrail["ef"],
            vmin=-1e12,
            vmax=1e12,
            transform=self.crs,
            cmap="coolwarm",
        )
        return plot

    def show_contrail_grid(self, contrail_grid, ax):
        plot = ax.pcolormesh(
            contrail_grid["longitude"],
            contrail_grid["latitude"],
            contrail_grid["ef_per_m"].transpose(),
            shading="gourard",
            vmin=-1e9,
            vmax=1e9,
            cmap="coolwarm",
            transform=ccrs.PlateCarree(),
        )
        return plot

    def show_grid(self, grid, ax, color="blue", s=0.2):
        return ax.scatter(
            grid["longitude"],
            grid["latitude"],
            transform=ccrs.PlateCarree(),
            color=color,
            s=s,
        )


class Map3D(Map):
    def __init__(self, crs=None):
        pass

    def _create_map(self, fig, grid_pos):
        ax = fig.add_subplot(int(grid_pos), projection="3d")

        lc = self.extract_map_geometry()
        ax.add_collection3d(lc, zs=30_000, zdir="z")

        ax.set_zlim(30000, 40000)
        ax.set_xlim(-75, 10)
        ax.set_ylim(35, 65)

        return ax

    def extract_map_geometry(self):
        coastline_geoms = COASTLINE.geometries()

        target_projection = ccrs.PlateCarree()
        geoms = [
            target_projection.project_geometry(geom, COASTLINE.crs)
            for geom in coastline_geoms
        ]
        paths = list(
            itertools.chain.from_iterable(geos_to_path(geom) for geom in geoms)
        )

        segments = []
        for path in paths:
            vertices = [vertex for vertex, _ in path.iter_segments()]
            vertices = np.asarray(vertices)
            segments.append(vertices)

        lc = LineCollection(segments, color="black", linewidth=0.5)
        return lc

    # Function to display altitude grid as 3D scatter plot
    # Method from https://stackoverflow.com/questions/23785408/3d-cartopy-similar-to-matplotlib-basemap
    def show_3d_grid(self, grid, ax):
        ax.scatter(
            grid["latitude"],
            grid["longitude"],
            grid["altitude"],
            c=grid["altitude"],  # Use altitude for color gradient
            cmap="viridis",  # Choose colormap for altitude
            marker="o",  # Set marker style
            alpha=0.2,
            depthshade=True,  # Enable depth shading for better visualization
        )

        ax.set_zlim(bottom=28_000)

        # Set labels for axes
        ax.set_xlabel("longitude")
        ax.set_ylabel("latitude")
        ax.set_zlabel("altitude")

        return ax

    def show_3d_path(self, flight_path, ax, color="k", linewidth=1):
        return ax.plot(
            flight_path["longitude"],
            flight_path["latitude"],
            flight_path["altitude_ft"],
            color=color,
            linewidth=linewidth,
        )

\end{minted}
\subsection{__init__.py}
\begin{minted}[breaklines,fontsize=\small]{python}
from .maps import Map, Map3D
import matplotlib.pyplot as plt
from .blank import Blank, Blank3D


class Display:
    def __init__(self):
        self.maps = Map()
        self.maps3d = Map3D()
        self.blank = Blank()
        self.blank3d = Blank3D()

    def show(self):
        plt.show()

\end{minted}
\subsection{display.py}
\begin{minted}[breaklines,fontsize=\small]{python}
from matplotlib.collections import PolyCollection
import shapely
import json
import config
import pandas as pd
from cartopy import crs as ccrs
import numpy as np
from matplotlib.animation import FuncAnimation

crs = ccrs.NearsidePerspective(central_latitude=51, central_longitude=-35)


def get_contrail_polys_at_time(contrail_polys, time):
    collections = {}
    polys = contrail_polys["polys"]
    for level in config.FLIGHT_LEVELS:
        patches = []
        for poly in polys:
            if (
                poly["properties"]["level"] == level
                and poly["properties"]["time"] == time
            ):
                multipoly = shapely.from_geojson(json.dumps(poly))
                for geom in multipoly.geoms:
                    geom = geom.simplify(0.1)
                    x, y = geom.exterior.coords.xy
                    patches.append(np.asarray(tuple(zip(x, y))))
        collection = PolyCollection(patches, facecolor="red", alpha=0.5)
        collections[level] = collection

    return collections


def convert_time_string(time):
    new_time_str = np.datetime_as_string(time, unit="s") + "Z"
    return new_time_str


def create_3d_flight_frame(
    timestep, flight_path, contrail_grid, contrail_polys, line, ax=None
):
    long = flight_path["longitude"][:timestep]
    lat = flight_path["latitude"][:timestep]
    alt = flight_path["altitude_ft"][:timestep]
    ax.set_title(f"Flight Path at Timestep {flight_path['time'][timestep]}")
    line.set_xdata(long)
    line.set_ydata(lat)
    line.set_3d_properties(alt)
    timestamps = contrail_grid["time"]

    # Interpolate contrail grid data at the given timestamp
    nearest_timestamp_index = np.argmin(
        np.abs(timestamps - np.datetime64(flight_path["time"][timestep])).values
    )
    time = convert_time_string(contrail_grid["time"][nearest_timestamp_index].values)
    polys = get_contrail_polys_at_time(contrail_polys, time)
    for col in ax.collections:
        if isinstance(col, PolyCollection):
            col.remove()
    for level in polys:
        ax.add_collection3d(polys[level], zs=level * 100, zdir="z")

    return line


def create_3d_flight_animation(
    flight_path,
    contrail_grid,
    contrail_polys,
    fig=None,
    ax=None,
    interval=200,
):
    flight_path_df = pd.DataFrame(
        flight_path, columns=["latitude", "longitude", "altitude_ft", "time"]
    )
    line = ax.plot(
        flight_path_df["longitude"][0],
        flight_path_df["latitude"][0],
        flight_path_df["altitude_ft"][0],
        color="b",
    )[0]

    time = convert_time_string(contrail_grid["time"][0].values)
    polys = get_contrail_polys_at_time(contrail_polys, time)
    for level in polys:
        ax.add_collection3d(polys[level], zs=level * 100, zdir="z")

    ax.set_xlabel("Longitude")
    ax.set_ylabel("Latitude")
    ax.set_zlabel("Altitude")
    ani = FuncAnimation(
        fig,
        create_3d_flight_frame,
        frames=len(flight_path),
        interval=interval,
        fargs=(flight_path_df, contrail_grid, contrail_polys, line, ax),
        blit=False,
    )
    return ani


def create_flight_frame(hours, flight_path, contrail_grid, line, grid, title, ax=None):
    time = flight_path["time"].iloc[0] + pd.Timedelta(hours=hours * 2)

    flight_path_before_time = flight_path[flight_path["time"] <= time]

    lon = flight_path_before_time["longitude"]
    lat = flight_path_before_time["latitude"]

    ax.set_title(
        f"{title} at Timestep {time.strftime('%H:%M')}, Altitude: {flight_path_before_time['altitude_ft'].iloc[-1]} ft"
    )
    line.set_xdata(lon)
    line.set_ydata(lat)
    timestamps = contrail_grid["time"]

    # Interpolate contrail grid data at the given timestamp
    nearest_timestamp_index = np.argmin(np.abs(timestamps - np.datetime64(time)).values)

    nearest_flight_level_index = np.argmin(
        np.abs(
            config.FLIGHT_LEVELS
            - (flight_path_before_time["altitude_ft"].iloc[-1] / 100)
        )
    )
    interpolated_grid = contrail_grid.isel(
        flight_level=nearest_flight_level_index, time=nearest_timestamp_index
    )

    transposed = interpolated_grid["ef_per_m"].transpose().values
    grid.set_array(transposed.ravel())
    return line, grid


def create_flight_animation(
    flight_path,
    contrail_grid,
    title="Flight path",
    fig=None,
    ax=None,
    interval=1000,
):
    flight_path_df = pd.DataFrame(
        flight_path, columns=["latitude", "longitude", "time", "altitude_ft"]
    )
    line = ax.plot(
        flight_path_df["longitude"][0],
        flight_path_df["latitude"][0],
        transform=ccrs.PlateCarree(),
        color="b",
    )[0]
    contrail_data = contrail_grid.isel(flight_level=4, time=0)
    grid = ax.pcolormesh(
        contrail_data["longitude"],
        contrail_data["latitude"],
        contrail_data["ef_per_m"].transpose(),
        shading="gourard",
        vmin=-1e9,
        vmax=1e9,
        cmap="coolwarm",
        transform=ccrs.PlateCarree(),
    )

    ax.set_xlabel("Longitude")
    ax.set_ylabel("Latitude")
    ani = FuncAnimation(
        fig,
        create_flight_frame,
        frames=5,
        interval=interval,
        fargs=(flight_path_df, contrail_grid, line, grid, title, ax),
        blit=False,
    )
    return ani


def create_aco_frame(index, paths, line, ax, best_indexes, best_path):
    flight_path = paths[index]
    flight_path_df = pd.DataFrame(
        flight_path, columns=["latitude", "longitude", "time", "altitude_ft"]
    )
    lon = flight_path_df["longitude"]
    lat = flight_path_df["latitude"]
    line.set_xdata(lon)
    line.set_ydata(lat)

    if index in best_indexes:
        best_path_df = pd.DataFrame(
            best_indexes[index],
            columns=["latitude", "longitude", "time", "altitude_ft"],
        )
        best_path.set_xdata(best_path_df["longitude"])
        best_path.set_ydata(best_path_df["latitude"])

    ax.set_title(f"Path #{index}")

    return line, best_path


def create_aco_animation(
    paths,
    best_indexes,
    fig=None,
    ax=None,
    interval=100,
):
    flight_path_df = pd.DataFrame(
        paths[0], columns=["latitude", "longitude", "time", "altitude_ft"]
    )
    line = ax.plot(
        flight_path_df["longitude"],
        flight_path_df["latitude"],
        transform=ccrs.PlateCarree(),
        c="k",
        alpha=0.5,
        linewidth=0.5,
    )[0]

    best_path_df = pd.DataFrame(
        best_indexes[0], columns=["latitude", "longitude", "time", "altitude_ft"]
    )
    best_path = ax.plot(
        best_path_df["longitude"],
        best_path_df["latitude"],
        transform=ccrs.PlateCarree(),
        c="r",
    )[0]

    ax.set_xlabel("Longitude")
    ax.set_ylabel("Latitude")
    ani = FuncAnimation(
        fig,
        create_aco_frame,
        frames=len(paths),
        interval=interval,
        fargs=(paths, line, ax, best_indexes, best_path),
        blit=False,
    )
    return ani

\end{minted}
\subsection{blank.py}
\begin{minted}[breaklines,fontsize=\small]{python}
import matplotlib.pyplot as plt
import matplotlib.ticker as ticker
from itertools import cycle


class Blank:
    def __init__(self):
        pass

    def create_fig(self, grid_width, grid_height):
        fig = plt.figure()
        axs = []
        for i in range(1, grid_width * grid_height + 1):
            ax = self._create_plot(fig, f"{grid_height}{grid_width}{i}")
            axs.append(ax)
        return fig, axs

    def _create_plot(self, fig, grid_pos):
        ax = fig.add_subplot(int(grid_pos))
        return ax

    def show_plot(
        self,
        x,
        ax,
        color="k",
        linewidth=1,
        linestyle="solid",
        x_label=None,
        y_label=None,
        title=None,
    ):
        ax.plot(
            x,
            color=color,
            linestyle=linestyle,
            linewidth=linewidth,
        )
        ax.xaxis.set_major_locator(ticker.MaxNLocator(integer=True))
        ax.set_xlabel(x_label)
        ax.set_ylabel(y_label)
        ax.set_title(title)


class Blank3D(Blank):
    def show_front(self, front, ax):
        ax.plot(front["co2"], front["contrail"], front["time"], "ro")
        ax.set_xlabel("CO2")
        ax.set_ylabel("Contrail EF")
        ax.set_zlabel("Time")
        ax.set_title("Pareto Front")

    def compare_fronts(self, fronts, ax):
        cycol = cycle(
            [
                "turquoise",
                "darkorchid",
                "coral",
                "greenyellow",
                "hotpink",
                "gold",
                "royalblue",
            ]
        )
        cysym = cycle("o^s*P")
        for front in fronts:
            ax.plot(
                front["co2"],
                front["contrail"],
                front["time"],
                next(cysym),
                color=next(cycol),
                label=front.name,
            )

        ax.set_xlabel("CO2")
        ax.set_ylabel("Contrail EF")
        ax.set_zlabel("Time")
        ax.legend()

    def _create_plot(self, fig, grid_pos):
        ax = fig.add_subplot(int(grid_pos), projection="3d")
        return ax

\end{minted}
\section{data}
\section{routing_graph}
\subsection{routing_grid.py}
\begin{minted}[breaklines,fontsize=\small]{python}
import numpy as np
import typing

if typing.TYPE_CHECKING:
    from _types import Point2D, Path2D, Grid2D
    from config import Config


class RoutingGrid:
    """
    A class representing a routing grid based on geodesic paths
    """

    def __init__(self, geodesic_path: "Path2D", config: "Config"):
        """
        Initialises the RoutingGrid object
        """
        self.config = config
        self.path = geodesic_path

    def calculate_new_coordinates(
        self, p1: "Point2D", distance: float, bearing: float
    ) -> "Point2D":
        """
        Calculates new coordinates based on initial point, distance, and bearing
        """
        lat1, lon1 = p1

        lat1 = np.radians(lat1)
        lon1 = np.radians(lon1)

        lat2 = np.arcsin(
            np.sin(lat1) * np.cos(distance / self.config.R)
            + np.cos(lat1) * np.sin(distance / self.config.R) * np.cos(bearing)
        )
        lon2 = lon1 + np.arctan2(
            np.sin(bearing) * np.sin(distance / self.config.R) * np.cos(lat1),
            np.cos(distance / self.config.R) - np.sin(lat1) * np.sin(lat2),
        )

        return np.degrees(lat2), np.degrees(lon2)

    def calculate_normal_bearing(self, bearing: float) -> float:
        """
        Calculates the normal bearing by adding pi/2 to the given bearing
        """
        return (bearing + np.pi / 2) % (2 * np.pi)

    def calculate_bearing(self, p1: "Point2D", p2: "Point2D") -> float:
        """
        Calculates the bearing between two points
        """
        lat1, lon1 = p1
        lat2, lon2 = p2
        delta_lon = lon2 - lon1

        lat1 = np.radians(lat1)
        lat2 = np.radians(lat2)
        delta_lon = np.radians(delta_lon)

        x = np.cos(lat1) * np.sin(lat2) - np.sin(lat1) * np.cos(lat2) * np.cos(
            delta_lon
        )
        y = np.sin(delta_lon) * np.cos(lat1)
        z = np.arctan2(y, x) % (2 * np.pi)  # Convert to range [0, 2pi]

        return z

    def calculate_routing_grid(self) -> "Grid2D":
        """
        Calculates the routing grid
        """
        grid = []
        for point in self.path:
            lat, lon = point
            positive_waypoints = []
            negative_waypoints = []
            potential_waypoints = []
            for i in range(1, self.config.GRID_WIDTH + 1):
                index = self.path.index(point)

                if index + (i / self.config.OFFSET_VAR) > len(self.path) - 1:
                    continue

                if index + 1 > len(self.path) - 1:
                    continue

                bearing = self.calculate_bearing(self.path[index], self.path[index + 1])
                bearing = self.calculate_normal_bearing(bearing)

                new_point_positive = self.calculate_new_coordinates(
                    point, self.config.GRID_SPACING * i, bearing
                )
                new_point_negative = self.calculate_new_coordinates(
                    point, self.config.GRID_SPACING * i * -1, bearing
                )
                plat, plon = new_point_positive
                nlat, nlon = new_point_negative
                positive_waypoints.append((plat, plon))
                negative_waypoints.append((nlat, nlon))
            # reverse positive waypoints
            positive_waypoints = list(reversed(positive_waypoints))
            potential_waypoints = positive_waypoints + [(lat, lon)] + negative_waypoints

            grid.append(potential_waypoints)
        return grid

    def get_routing_grid(self) -> "Grid2D":
        """
        Gets the routing grid
        """
        if not hasattr(self, "routing_grid"):
            self.routing_grid = self.calculate_routing_grid()
        return self.routing_grid

\end{minted}
\subsection{__init__.py}
\begin{minted}[breaklines,fontsize=\small]{python}
from .routing_grid import RoutingGrid
from .altitude_grid import AltitudeGrid
from .geodesic_path import GeodesicPath
from .routing_graph import RoutingGraph
import typing

if typing.TYPE_CHECKING:
    from config import Config
    from _types import IndexPoint3D, FlightPoint
    from performance_model import PerformanceModel


class RoutingGraphManager:
    def __init__(self, config: "Config"):
        """
        External interface for the routing graph and all its components
        """
        self.config: "Config" = config

        self.geodesic_path: "GeodesicPath" = GeodesicPath(self.config)
        self.routing_grid: "RoutingGrid" = RoutingGrid(self.geodesic_path, self.config)
        self.altitude_grid: "AltitudeGrid" = AltitudeGrid(
            self.routing_grid, self.config
        )

    def convert_index_to_point(self, index: "IndexPoint3D") -> "FlightPoint":
        """
        Converts an IndexPoint to a FlightPoint
        """
        return self.altitude_grid.convert_index_to_point(index)

    def get_routing_graph(self) -> "RoutingGraph":
        """
        Retrieves the routing graph, or creates it if it doesn't exist
        """
        if not hasattr(self, "routing_graph"):
            self.routing_graph = RoutingGraph(
                self.get_altitude_grid(), self.get_performance_model(), self.config
            )
        return self.routing_graph

    def set_performance_model(self, performance_model: "PerformanceModel") -> None:
        """
        Sets the performance model for the routing graph
        """
        self.performance_model: "PerformanceModel" = performance_model

    def get_performance_model(self) -> "PerformanceModel":
        """
        Retrieves the performance model
        """
        if not hasattr(self, "performance_model"):
            raise ValueError("Performance model not set")
        return self.performance_model

    def get_routing_grid(self) -> "RoutingGrid":
        """
        Retrieves the routing grid
        """
        return self.routing_grid

    def get_altitude_grid(self) -> "AltitudeGrid":
        """
        Retrieves the altitude grid
        """
        return self.altitude_grid

    def get_geodesic_path(self) -> "GeodesicPath":
        """
        Retrieves the geodesic path
        """
        return self.geodesic_path

\end{minted}
\subsection{altitude_grid.py}
\begin{minted}[breaklines,fontsize=\small]{python}
import typing
from utils import Conversions

if typing.TYPE_CHECKING:
    from _types import Grid2D, Grid3D, IndexPoint3D, FlightPoint
    from config import Config


class AltitudeGrid:
    """
    A class representing an altitude grid based on a routing grid
    """

    def __init__(self, routing_grid: "Grid2D", config: "Config"):
        """
        Constructs an AltitudeGrid object from a routing grid
        """
        self.config: "Config" = config
        self.base_altitude: int = self.config.STARTING_ALTITUDE
        self.altitude_step: int = self.config.ALTITUDE_STEP
        self.max_altitude_var: int = self.config.MAX_ALTITUDE_VAR
        self.max_altitude: int = self.config.MAX_ALTITUDE
        self.routing_grid: "Grid2D" = routing_grid.get_routing_grid()
        self.altitude_grid: "Grid3D" = self.calculate_altitude_grid(self.routing_grid)

    def calculate_altitude_grid(self, grid: "Grid2D") -> "Grid3D":
        """
        Calculates which points are reachable at each altitude, and constructs the grid object
        """

        def calculate_altitudes() -> list[int]:
            altitudes = []
            current_altitude = self.base_altitude
            while current_altitude <= self.max_altitude:
                altitudes.append(current_altitude)
                current_altitude += self.altitude_step
            return altitudes

        altitudes = calculate_altitudes()
        altitude_grid = {}

        for altitude in altitudes:
            altitude_grid[altitude] = []
            for step in grid:
                step_points = []
                for point in step:
                    index = grid.index(step)
                    max_altitude_at_step = min(
                        self.base_altitude + (index * self.max_altitude_var),
                        self.max_altitude,
                    )
                    if altitude > max_altitude_at_step:
                        step_points.append(None)
                        continue
                    step_points.append(point)
                if len(step_points) > 0:
                    altitude_grid[altitude].append(step_points)

        return altitude_grid

    def convert_index_to_point(self, index: "IndexPoint3D") -> "FlightPoint":
        """
        Converts an IndexPoint to a FlightPoint
        """
        thrust = self.config.NOMINAL_THRUST
        altitude_point = self.altitude_grid[index[2]][index[0]][index[1]]
        path_point = {
            "latitude": altitude_point[0],
            "longitude": altitude_point[1],
            "altitude_ft": index[2],
            "thrust": thrust,
            "level": Conversions().convert_altitude_to_pressure_bounded(
                index[2],
                self.config.PRESSURE_LEVELS[-1],
                self.config.PRESSURE_LEVELS[0],
            ),
        }
        return path_point

    def __iter__(self) -> "iter":
        return iter(self.altitude_grid)

    def __getitem__(self, key: int) -> "Grid2D":
        return self.altitude_grid[key]

    def __setitem__(self, key: int, value: "Grid2D") -> None:
        self.altitude_grid[key] = value

\end{minted}
\subsection{geodesic_path.py}
\begin{minted}[breaklines,fontsize=\small]{python}
import numpy as np
import typing

if typing.TYPE_CHECKING:
    from config import Config
    from _types import Point2D, Path2D


class GeodesicPath(list):
    """
    A class representing the geodesic path between two points.
    """

    def __init__(self, config: "Config"):
        """
        Initializes the GeodesicPath object.
        """
        self.departure_airport: Point2D = config.DEPARTURE_AIRPORT
        self.destination_airport: Point2D = config.DESTINATION_AIRPORT
        self.no_of_points: int = config.NO_OF_POINTS
        self.config: "Config" = config
        self.path: "Path2D" = self.calculate_path(
            self.no_of_points, self.departure_airport, self.destination_airport
        )
        super().__init__(self.path)

    def reduce_angle(self, angle: float) -> float:
        """
        Reduces an angle to the range -180 to 180 degrees.
        """
        while angle < -180:
            angle += 360
        while angle > 180:
            angle -= 360
        return angle

    def calculate_alpha1(self, phi1: float, phi2: float, delta: float) -> float:
        """
        Calculates the initial alpha angle.
        """
        numerator = np.cos(phi2) * np.sin(delta)
        denominator = (np.cos(phi1) * np.sin(phi2)) - (
            np.sin(phi1) * np.cos(phi2) * np.cos(delta)
        )

        alpha1 = np.arctan2(numerator, denominator)

        return alpha1

    def calculate_central_angle(self, phi1: float, phi2: float, delta: float) -> float:
        """
        Calculates the central angle (through the Earth's core) between two points.
        """
        numerator = np.sqrt(
            pow(
                (
                    (np.cos(phi1) * np.sin(phi2))
                    - np.sin(phi1) * np.cos(phi2) * np.cos(delta)
                ),
                2,
            )
            + pow((np.cos(phi2) * np.sin(delta)), 2)
        )
        denominator = (np.sin(phi1) * np.sin(phi2)) + np.cos(phi1) * np.cos(
            phi2
        ) * np.cos(delta)

        central_angle = np.arctan2(numerator, denominator)
        return central_angle

    def calculate_azimuth(self, alpha1: float, phi1: float) -> float:
        """
        Calculates the azimuth based off the longitude and the initial alpha angle.
        """
        numerator = np.sin(alpha1) * np.cos(phi1)
        denominator = np.sqrt(
            np.cos(alpha1) ** 2 + (np.sin(alpha1) ** 2 * np.sin(phi1) ** 2)
        )
        azimuth = np.arctan2(numerator, denominator)
        return azimuth

    def calculate_angle_1(self, alpha1: float, phi1: float) -> float:
        """
        Calculates the angle between the alpha1 and the longitude.
        """
        if phi1 == 0 and alpha1 == np.pi / 2:
            return 0
        numerator = np.tan(phi1)
        denominator = np.cos(alpha1)
        angle1 = np.arctan2(numerator, denominator)
        return angle1

    def calculate_equator_longitude(
        self, azimuth: float, angle1: float, lamda1: float
    ) -> float:
        """
        Calculate the longitude at the intersection with the equator.
        """
        numerator = np.sin(azimuth) * np.sin(angle1)
        denominator = np.cos(angle1)
        equator_longitude = lamda1 - np.arctan2(numerator, denominator)
        return equator_longitude

    def find_point_distance_along_great_circle(
        self, distance: float, azimuth: float, equator_longitude: float
    ) -> "Point2D":
        """
        Find a lat/lon point a certain distance along the great circle path.
        """
        phi_numerator = np.cos(azimuth) * np.sin(distance)
        phi_denominator = np.sqrt(
            pow(np.cos(distance), 2)
            + (pow(np.sin(azimuth), 2) * pow(np.sin(distance), 2))
        )
        phi = np.arctan2(phi_numerator, phi_denominator)
        lambda_numerator = np.sin(azimuth) * np.sin(distance)
        lambda_denominator = np.cos(distance)
        lambda1 = np.arctan2(lambda_numerator, lambda_denominator) + equator_longitude

        phi = np.degrees(phi)
        lambda1 = np.degrees(lambda1)

        return (self.reduce_angle(phi), self.reduce_angle(lambda1))

    def calculate_path(
        self, no_of_points: int, p1: "Point2D", p2: "Point2D"
    ) -> "Path2D":
        """
        Calculates the geodesic path with several points evenly spaced between two points.
        """
        lat0, lon0 = p1
        lat1, lon1 = p2

        phi1 = np.radians(lat0)
        lambda1 = np.radians(lon0)
        phi2 = np.radians(lat1)
        lambda2 = np.radians(lon1)

        delta = lambda2 - lambda1
        delta = self.reduce_angle(delta)

        alpha1 = self.calculate_alpha1(phi1, phi2, delta)

        azimuth = self.calculate_azimuth(alpha1, phi1)

        central_angle = self.calculate_central_angle(phi1, phi2, delta)

        angle1 = self.calculate_angle_1(alpha1, phi1)
        equator_longitude = self.calculate_equator_longitude(azimuth, angle1, lambda1)

        points = [(lat0, lon0)]

        total_distance = self.config.R * central_angle
        step = total_distance / no_of_points
        for i in range(1, no_of_points):
            distance = angle1 + ((i * step) / self.config.R)
            points.append(
                self.find_point_distance_along_great_circle(
                    distance, azimuth, equator_longitude
                )
            )

        points.append((lat1, lon1))

        return points

\end{minted}
\subsection{routing_graph.py}
\begin{minted}[breaklines,fontsize=\small]{python}
from networkx import DiGraph, read_gml, write_gml
from networkx.classes.reportviews import NodeView, EdgeView
import os
from rich.progress import Progress, SpinnerColumn, TextColumn
from rich import print
import typing

if typing.TYPE_CHECKING:
    from config import Config
    from performance_model import PerformanceModel
    from .altitude_grid import AltitudeGrid
    from _types import IndexPoint3D, Grid3D


class RoutingGraph:
    def __init__(
        self,
        altitude_grid: "AltitudeGrid",
        performance_model: "PerformanceModel",
        config: "Config",
        test: bool = False,
    ):
        """
        Create a RoutingGraph object
        """
        self.config: "Config" = config
        self.altitude_grid: "AltitudeGrid" = altitude_grid
        self.performance_model: "PerformanceModel" = performance_model
        self.routing_graph: DiGraph = self._init_routing_graph(test=test)
        self.nodes: NodeView = self.routing_graph.nodes
        self.edges: EdgeView = self.routing_graph.edges

    def get_consecutive_points(
        self,
        point: "IndexPoint3D",
        grid: "Grid3D",
    ) -> list["IndexPoint3D"] or None:
        """
        Get a list of consecutive points from the current position
        """

        xi, yi, altitude = point
        max_lateral_var = self.config.OFFSET_VAR
        max_altitude_var = self.config.MAX_ALTITUDE_VAR
        altitude_step = self.config.ALTITUDE_STEP
        max_alt = altitude + max_altitude_var
        max_alt = max(
            self.config.STARTING_ALTITUDE, min(max_alt, self.config.MAX_ALTITUDE)
        )

        points = []
        current_altitude = altitude
        while current_altitude <= max_alt:
            if xi + 1 == len(grid[current_altitude]):
                return None
            next_layer_length = len(grid[current_altitude][xi + 1]) - 1
            min_i = min(max(yi - max_lateral_var, 0), next_layer_length)
            max_i = min(yi + max_lateral_var, next_layer_length)
            for i in range(min_i, max_i + 1):
                points.append((xi + 1, i, current_altitude))
            current_altitude += altitude_step

        return points

    def calculate_routing_graph(self) -> DiGraph:
        """
        Calculates a full routing graph from an altitude grid
        """
        graph = DiGraph()

        altitude_grid = self.altitude_grid

        for altitude in altitude_grid:
            for step in altitude_grid[altitude]:
                for point in step:
                    if point is None:
                        continue

                    xi = altitude_grid[altitude].index(step)
                    yi = step.index(point)

                    consecutive_points = self.get_consecutive_points(
                        (xi, yi, altitude), altitude_grid
                    )

                    heuristic_data = {
                        f"{objective(self.performance_model,self.config)}_heuristic": objective(
                            self.performance_model, self.config
                        ).calculate_heuristic((*point, altitude))
                        for objective in self.config.OBJECTIVES
                    }

                    if consecutive_points is None:
                        continue
                    graph.add_node(
                        (xi, yi, altitude),
                        **heuristic_data,
                    )
                    for next_point in consecutive_points:
                        pheromone_data = {
                            f"{objective(self.performance_model,self.config)}_pheromone": self.config.TAU_MAX
                            for objective in self.config.OBJECTIVES
                        }
                        next_heuristic_data = {
                            f"{objective(self.performance_model,self.config)}_heuristic": objective(
                                self.performance_model, self.config
                            ).calculate_heuristic(next_point)
                            for objective in self.config.OBJECTIVES
                        }

                        graph.add_edge(
                            (xi, yi, altitude),
                            (next_point[0], next_point[1], next_point[2]),
                            **pheromone_data,
                        )
                        next_lat, next_lon, _ = next_point

                        graph.add_node(
                            (next_point[0], next_point[1], next_point[2]),
                            **next_heuristic_data,
                        )

        return graph

    def parse_node(self, s: str) -> "IndexPoint3D":
        """
        Parses a GML node into an IndexPoint3D
        """
        parts = s.strip("()").split(",")
        return tuple(map(int, parts))

    def __getitem__(self, key: "IndexPoint3D") -> NodeView:
        return self.routing_graph[key]

    def _init_routing_graph(self, test: bool = False) -> DiGraph:
        """
        Retrieves the routing graph from a file or calculates it
        """
        with Progress(
            SpinnerColumn(),
            TextColumn("[progress.description]{task.description}"),
            transient=True,
        ) as progress:
            progress.add_task(description="Creating routing graph...", total=None)
            if os.path.exists("data/routing_graph.gml") and not test:
                rg = read_gml("data/routing_graph.gml", destringizer=self.parse_node)
                self.routing_graph = rg
            else:
                rg = self.calculate_routing_graph()
                if not test:
                    write_gml(rg, "data/routing_graph.gml")
                self.routing_graph = rg
        print("[bold green]:white_check_mark: Routing graph constructed.[/bold green]")
        return self.routing_graph

\end{minted}
\subsection{Tests}
\subsubsection{__init__.py}
\begin{minted}[breaklines,fontsize=\small]{python}

\end{minted}
\subsubsection{test_altitude_grid.py}
\begin{minted}[breaklines,fontsize=\small]{python}
import unittest
from ..altitude_grid import AltitudeGrid
from config import Config


class TestAltitudeGrid(unittest.TestCase):
    def setUp(self):
        class MockRoutingGrid:
            def get_routing_grid(self):
                return [
                    [(0, 0), (1, 1), (2, 2)],
                    [(3, 3), (4, 4), (5, 5)],
                    [(6, 6), (7, 7), (8, 8)],
                ]

        class MockConfig(Config):
            STARTING_ALTITUDE = 0
            ALTITUDE_STEP = 1
            MAX_ALTITUDE = 3
            NOMINAL_THRUST = 100
            PRESSURE_LEVELS = [1000, 900, 800]

        self.mock_routing_grid = MockRoutingGrid()
        self.mock_config = MockConfig()
        self.altitude_grid = AltitudeGrid(self.mock_routing_grid, self.mock_config)

    def test_calculate_altitude_grid(self):
        altitude_grid = self.altitude_grid.calculate_altitude_grid(
            [
                [(0, 0), (1, 1), (2, 2)],
                [(3, 3), (4, 4), (5, 5)],
                [(6, 6), (7, 7), (8, 8)],
            ]
        )
        self.assertEqual(len(altitude_grid), 4)
        self.assertEqual(len(altitude_grid[0]), 3)
        self.assertEqual(len(altitude_grid[0][0]), 3)

    def test_convert_index_to_point(self):
        point = self.altitude_grid.convert_index_to_point((0, 0, 0))
        # Assert expected point attributes
        self.assertEqual(point["latitude"], 0)
        self.assertEqual(point["longitude"], 0)
        self.assertEqual(point["altitude_ft"], 0)
        self.assertEqual(point["thrust"], 100)
        self.assertAlmostEqual(point["level"], 1000)

    def test_iteration(self):
        for altitude in self.altitude_grid:
            self.assertTrue(altitude in range(0, 4))
            for step_points in self.altitude_grid[altitude]:
                self.assertEqual(len(step_points), 3)
                for step in step_points:
                    self.assertTrue(step is None or len(step) == 2)

    def test_getitem(self):
        step_points = self.altitude_grid[0]
        # Assert step points for altitude 5
        self.assertEqual(len(step_points), 3)

    def test_setitem(self):
        # Modify altitude grid and assert the change
        self.altitude_grid[0] = [(0, 0), (0, 0), (0, 0)]
        self.assertEqual(self.altitude_grid[0], [(0, 0), (0, 0), (0, 0)])

\end{minted}
\subsubsection{test_routing_graph.py}
\begin{minted}[breaklines,fontsize=\small]{python}
import unittest
from routing_graph import RoutingGraph
from config import Config


class TestRoutingGraph(unittest.TestCase):
    def setUp(self):
        class MockAltitudeGrid:
            def __init__(self):
                self.altitude_grid = {
                    0: [
                        [(0, 0), (1, 1), (2, 2)],
                        [(3, 3), (4, 4), (5, 5)],
                        [(6, 6), (7, 7), (8, 8)],
                    ],
                    1: [
                        [None, None, None],
                        [(3, 3), (4, 4), (5, 5)],
                        [(6, 6), (7, 7), (8, 8)],
                    ],
                }

            def __iter__(self):
                return iter(self.altitude_grid)

            def __setitem__(self, key, value):
                self.altitude_grid[key] = value

            def __getitem__(self, key):
                return self.altitude_grid[key]

        class MockObjective:
            def __init__(self, performance_model, config):
                self.config = config
                self.name = "test"
                self.performance_model = performance_model

            def calculate_heuristic(self, point):
                return 1

            def __str__(self):
                return self.name

        class MockConfig(Config):
            OBJECTIVES = [MockObjective]
            STARTING_ALTITUDE = 0
            MAX_ALTITUDE = 0
            OFFSET_VAR = 1
            ALTITUDE_STEP = 1
            TAU_MAX = 1

        class MockPerformanceModel:
            pass

        self.mock_altitude_grid = MockAltitudeGrid()
        self.mock_performance_model = MockPerformanceModel()
        self.mock_config = MockConfig()
        self.routing_graph = RoutingGraph(
            self.mock_altitude_grid,
            self.mock_performance_model,
            self.mock_config,
            test=True,
        )

    def test_get_consecutive_points(self):
        points = self.routing_graph.get_consecutive_points(
            (0, 0, 0), self.mock_altitude_grid
        )
        # Assert that points are correctly calculated
        self.assertEqual(points, [(1, 0, 0), (1, 1, 0)])

    def test_calculate_routing_graph(self):
        graph = self.routing_graph.calculate_routing_graph()
        # Assert expected number of nodes and edges
        self.assertEqual(len(graph.nodes), 15)
        self.assertEqual(len(graph.edges), 14)

    def test_parse_node(self):
        node = self.routing_graph.parse_node("(0, 0, 31000)")
        # Assert parsing of node string
        self.assertEqual(node, (0, 0, 31000))

    def test_init_routing_graph(self):
        routing_graph = self.routing_graph._init_routing_graph(test=True)
        # Assert initialization of routing graph
        self.assertEqual(len(routing_graph.nodes), 15)
        self.assertEqual(len(routing_graph.edges), 14)  # 8 edges

    def test_getitem(self):
        item = self.routing_graph[(0, 0, 0)]
        # Assert getting an item from routing graph
        self.assertIsNotNone(item)

    def test_pheromones(self):
        routing_graph = self.routing_graph._init_routing_graph(test=True)
        for edge in routing_graph.edges:
            pheromones = routing_graph.edges[edge]["test_pheromone"]
            self.assertEqual(pheromones, 1)

    def test_heuristic(self):
        routing_graph = self.routing_graph._init_routing_graph(test=True)
        for node in routing_graph.nodes:
            heuristic = routing_graph.nodes[node]["test_heuristic"]
            self.assertEqual(heuristic, 1)

\end{minted}
\subsubsection{test_geodesic_path.py}
\begin{minted}[breaklines,fontsize=\small]{python}
import unittest
from ..geodesic_path import GeodesicPath


class TestGeodesicPath(unittest.TestCase):
    def setUp(self):
        class Config:
            DEPARTURE_AIRPORT = (40.7128, -74.0060)  # New York City
            DESTINATION_AIRPORT = (34.0522, -118.2437)  # Los Angeles
            NO_OF_POINTS = 100
            R = 6371  # Earth's radius in kilometers

        self.config = Config()

    def test_reduce_angle(self):
        geodesic_path = GeodesicPath(self.config)
        angle = geodesic_path.reduce_angle(360)
        self.assertEqual(angle, 0)

    def test_calculate_path(self):
        geodesic_path = GeodesicPath(self.config)
        path = geodesic_path.calculate_path(100, (0, 0), (0, 1))
        self.assertIsInstance(path, list)
        self.assertEqual(len(path), 101)

    def test_calculate_alpha1(self):
        geodesic_path = GeodesicPath(self.config)
        alpha = geodesic_path.calculate_alpha1(0, 0, 0)
        self.assertAlmostEqual(alpha, 0)

    def test_calculate_central_angle(self):
        geodesic_path = GeodesicPath(self.config)
        central_angle = geodesic_path.calculate_central_angle(0, 0, 0)
        self.assertAlmostEqual(central_angle, 0)

    def test_calculate_azimuth(self):
        geodesic_path = GeodesicPath(self.config)
        azimuth = geodesic_path.calculate_azimuth(0, 0)
        self.assertAlmostEqual(azimuth, 0)

    def test_calculate_angle_1(self):
        geodesic_path = GeodesicPath(self.config)
        angle1 = geodesic_path.calculate_angle_1(0, 0)
        self.assertAlmostEqual(angle1, 0)

    def test_calculate_equator_longitude(self):
        geodesic_path = GeodesicPath(self.config)
        equator_longitude = geodesic_path.calculate_equator_longitude(0, 0, 0)
        self.assertAlmostEqual(equator_longitude, 0)

    def test_find_point_distance_along_great_circle(self):
        geodesic_path = GeodesicPath(self.config)
        point = geodesic_path.find_point_distance_along_great_circle(0, 0, 0)
        self.assertIsInstance(point, tuple)
        self.assertEqual(len(point), 2)

\end{minted}
\subsubsection{test_routing_grid.py}
\begin{minted}[breaklines,fontsize=\small]{python}
import unittest
from ..routing_grid import RoutingGrid


class TestRoutingGrid(unittest.TestCase):
    def setUp(self):
        class GeodesicPath(list):
            def __init__(self):
                self.path = [(0, 0), (1, 1), (2, 2)]
                super().__init__(self.path)

        class Config:
            R = 6371  # Earth's radius in kilometers
            GRID_WIDTH = 3
            GRID_SPACING = 100
            OFFSET_VAR = 1

        self.geodesic_path = GeodesicPath()
        self.config = Config()
        self.routing_grid = RoutingGrid(self.geodesic_path, self.config)

    def test_calculate_new_coordinates(self):
        new_coordinates = self.routing_grid.calculate_new_coordinates((0, 0), 100, 0)
        # Assert expected latitude, longitude, and bearing
        self.assertAlmostEqual(new_coordinates[0], 0.8993, places=3)
        self.assertAlmostEqual(new_coordinates[1], 0.0, places=3)

    def test_calculate_normal_bearing(self):
        normal_bearing = self.routing_grid.calculate_normal_bearing(0)
        # Assert expected normal bearing
        self.assertAlmostEqual(normal_bearing, 1.5708, places=3)

    def test_calculate_bearing(self):
        bearing = self.routing_grid.calculate_bearing((0, 0), (1, 1))
        # Assert expected bearing
        self.assertAlmostEqual(bearing, 0.7853, places=3)

    def test_calculate_routing_grid(self):
        routing_grid = self.routing_grid.calculate_routing_grid()
        # Assert expected length and structure of routing grid
        # Length should match number of points in path
        self.assertEqual(len(routing_grid), 3)
        # Width should match GRID_WIDTH
        self.assertEqual(len(routing_grid[0]), self.config.GRID_WIDTH * 2 - 1)

    def test_get_routing_grid(self):
        routing_grid = self.routing_grid.get_routing_grid()
        # Length should match number of points in path
        self.assertEqual(len(routing_grid), 3)
        # Width should match GRID_WIDTH
        self.assertEqual(len(routing_grid[0]), self.config.GRID_WIDTH * 2 - 1)

\end{minted}
\subsection{__init__.py}
\begin{minted}[breaklines,fontsize=\small]{python}

\end{minted}
\subsection{test_altitude_grid.py}
\begin{minted}[breaklines,fontsize=\small]{python}
import unittest
from ..altitude_grid import AltitudeGrid
from config import Config


class TestAltitudeGrid(unittest.TestCase):
    def setUp(self):
        class MockRoutingGrid:
            def get_routing_grid(self):
                return [
                    [(0, 0), (1, 1), (2, 2)],
                    [(3, 3), (4, 4), (5, 5)],
                    [(6, 6), (7, 7), (8, 8)],
                ]

        class MockConfig(Config):
            STARTING_ALTITUDE = 0
            ALTITUDE_STEP = 1
            MAX_ALTITUDE = 3
            NOMINAL_THRUST = 100
            PRESSURE_LEVELS = [1000, 900, 800]

        self.mock_routing_grid = MockRoutingGrid()
        self.mock_config = MockConfig()
        self.altitude_grid = AltitudeGrid(self.mock_routing_grid, self.mock_config)

    def test_calculate_altitude_grid(self):
        altitude_grid = self.altitude_grid.calculate_altitude_grid(
            [
                [(0, 0), (1, 1), (2, 2)],
                [(3, 3), (4, 4), (5, 5)],
                [(6, 6), (7, 7), (8, 8)],
            ]
        )
        self.assertEqual(len(altitude_grid), 4)
        self.assertEqual(len(altitude_grid[0]), 3)
        self.assertEqual(len(altitude_grid[0][0]), 3)

    def test_convert_index_to_point(self):
        point = self.altitude_grid.convert_index_to_point((0, 0, 0))
        # Assert expected point attributes
        self.assertEqual(point["latitude"], 0)
        self.assertEqual(point["longitude"], 0)
        self.assertEqual(point["altitude_ft"], 0)
        self.assertEqual(point["thrust"], 100)
        self.assertAlmostEqual(point["level"], 1000)

    def test_iteration(self):
        for altitude in self.altitude_grid:
            self.assertTrue(altitude in range(0, 4))
            for step_points in self.altitude_grid[altitude]:
                self.assertEqual(len(step_points), 3)
                for step in step_points:
                    self.assertTrue(step is None or len(step) == 2)

    def test_getitem(self):
        step_points = self.altitude_grid[0]
        # Assert step points for altitude 5
        self.assertEqual(len(step_points), 3)

    def test_setitem(self):
        # Modify altitude grid and assert the change
        self.altitude_grid[0] = [(0, 0), (0, 0), (0, 0)]
        self.assertEqual(self.altitude_grid[0], [(0, 0), (0, 0), (0, 0)])

\end{minted}
\subsection{test_routing_graph.py}
\begin{minted}[breaklines,fontsize=\small]{python}
import unittest
from routing_graph import RoutingGraph
from config import Config


class TestRoutingGraph(unittest.TestCase):
    def setUp(self):
        class MockAltitudeGrid:
            def __init__(self):
                self.altitude_grid = {
                    0: [
                        [(0, 0), (1, 1), (2, 2)],
                        [(3, 3), (4, 4), (5, 5)],
                        [(6, 6), (7, 7), (8, 8)],
                    ],
                    1: [
                        [None, None, None],
                        [(3, 3), (4, 4), (5, 5)],
                        [(6, 6), (7, 7), (8, 8)],
                    ],
                }

            def __iter__(self):
                return iter(self.altitude_grid)

            def __setitem__(self, key, value):
                self.altitude_grid[key] = value

            def __getitem__(self, key):
                return self.altitude_grid[key]

        class MockObjective:
            def __init__(self, performance_model, config):
                self.config = config
                self.name = "test"
                self.performance_model = performance_model

            def calculate_heuristic(self, point):
                return 1

            def __str__(self):
                return self.name

        class MockConfig(Config):
            OBJECTIVES = [MockObjective]
            STARTING_ALTITUDE = 0
            MAX_ALTITUDE = 0
            OFFSET_VAR = 1
            ALTITUDE_STEP = 1
            TAU_MAX = 1

        class MockPerformanceModel:
            pass

        self.mock_altitude_grid = MockAltitudeGrid()
        self.mock_performance_model = MockPerformanceModel()
        self.mock_config = MockConfig()
        self.routing_graph = RoutingGraph(
            self.mock_altitude_grid,
            self.mock_performance_model,
            self.mock_config,
            test=True,
        )

    def test_get_consecutive_points(self):
        points = self.routing_graph.get_consecutive_points(
            (0, 0, 0), self.mock_altitude_grid
        )
        # Assert that points are correctly calculated
        self.assertEqual(points, [(1, 0, 0), (1, 1, 0)])

    def test_calculate_routing_graph(self):
        graph = self.routing_graph.calculate_routing_graph()
        # Assert expected number of nodes and edges
        self.assertEqual(len(graph.nodes), 15)
        self.assertEqual(len(graph.edges), 14)

    def test_parse_node(self):
        node = self.routing_graph.parse_node("(0, 0, 31000)")
        # Assert parsing of node string
        self.assertEqual(node, (0, 0, 31000))

    def test_init_routing_graph(self):
        routing_graph = self.routing_graph._init_routing_graph(test=True)
        # Assert initialization of routing graph
        self.assertEqual(len(routing_graph.nodes), 15)
        self.assertEqual(len(routing_graph.edges), 14)  # 8 edges

    def test_getitem(self):
        item = self.routing_graph[(0, 0, 0)]
        # Assert getting an item from routing graph
        self.assertIsNotNone(item)

    def test_pheromones(self):
        routing_graph = self.routing_graph._init_routing_graph(test=True)
        for edge in routing_graph.edges:
            pheromones = routing_graph.edges[edge]["test_pheromone"]
            self.assertEqual(pheromones, 1)

    def test_heuristic(self):
        routing_graph = self.routing_graph._init_routing_graph(test=True)
        for node in routing_graph.nodes:
            heuristic = routing_graph.nodes[node]["test_heuristic"]
            self.assertEqual(heuristic, 1)

\end{minted}
\subsection{test_geodesic_path.py}
\begin{minted}[breaklines,fontsize=\small]{python}
import unittest
from ..geodesic_path import GeodesicPath


class TestGeodesicPath(unittest.TestCase):
    def setUp(self):
        class Config:
            DEPARTURE_AIRPORT = (40.7128, -74.0060)  # New York City
            DESTINATION_AIRPORT = (34.0522, -118.2437)  # Los Angeles
            NO_OF_POINTS = 100
            R = 6371  # Earth's radius in kilometers

        self.config = Config()

    def test_reduce_angle(self):
        geodesic_path = GeodesicPath(self.config)
        angle = geodesic_path.reduce_angle(360)
        self.assertEqual(angle, 0)

    def test_calculate_path(self):
        geodesic_path = GeodesicPath(self.config)
        path = geodesic_path.calculate_path(100, (0, 0), (0, 1))
        self.assertIsInstance(path, list)
        self.assertEqual(len(path), 101)

    def test_calculate_alpha1(self):
        geodesic_path = GeodesicPath(self.config)
        alpha = geodesic_path.calculate_alpha1(0, 0, 0)
        self.assertAlmostEqual(alpha, 0)

    def test_calculate_central_angle(self):
        geodesic_path = GeodesicPath(self.config)
        central_angle = geodesic_path.calculate_central_angle(0, 0, 0)
        self.assertAlmostEqual(central_angle, 0)

    def test_calculate_azimuth(self):
        geodesic_path = GeodesicPath(self.config)
        azimuth = geodesic_path.calculate_azimuth(0, 0)
        self.assertAlmostEqual(azimuth, 0)

    def test_calculate_angle_1(self):
        geodesic_path = GeodesicPath(self.config)
        angle1 = geodesic_path.calculate_angle_1(0, 0)
        self.assertAlmostEqual(angle1, 0)

    def test_calculate_equator_longitude(self):
        geodesic_path = GeodesicPath(self.config)
        equator_longitude = geodesic_path.calculate_equator_longitude(0, 0, 0)
        self.assertAlmostEqual(equator_longitude, 0)

    def test_find_point_distance_along_great_circle(self):
        geodesic_path = GeodesicPath(self.config)
        point = geodesic_path.find_point_distance_along_great_circle(0, 0, 0)
        self.assertIsInstance(point, tuple)
        self.assertEqual(len(point), 2)

\end{minted}
\subsection{test_routing_grid.py}
\begin{minted}[breaklines,fontsize=\small]{python}
import unittest
from ..routing_grid import RoutingGrid


class TestRoutingGrid(unittest.TestCase):
    def setUp(self):
        class GeodesicPath(list):
            def __init__(self):
                self.path = [(0, 0), (1, 1), (2, 2)]
                super().__init__(self.path)

        class Config:
            R = 6371  # Earth's radius in kilometers
            GRID_WIDTH = 3
            GRID_SPACING = 100
            OFFSET_VAR = 1

        self.geodesic_path = GeodesicPath()
        self.config = Config()
        self.routing_grid = RoutingGrid(self.geodesic_path, self.config)

    def test_calculate_new_coordinates(self):
        new_coordinates = self.routing_grid.calculate_new_coordinates((0, 0), 100, 0)
        # Assert expected latitude, longitude, and bearing
        self.assertAlmostEqual(new_coordinates[0], 0.8993, places=3)
        self.assertAlmostEqual(new_coordinates[1], 0.0, places=3)

    def test_calculate_normal_bearing(self):
        normal_bearing = self.routing_grid.calculate_normal_bearing(0)
        # Assert expected normal bearing
        self.assertAlmostEqual(normal_bearing, 1.5708, places=3)

    def test_calculate_bearing(self):
        bearing = self.routing_grid.calculate_bearing((0, 0), (1, 1))
        # Assert expected bearing
        self.assertAlmostEqual(bearing, 0.7853, places=3)

    def test_calculate_routing_grid(self):
        routing_grid = self.routing_grid.calculate_routing_grid()
        # Assert expected length and structure of routing grid
        # Length should match number of points in path
        self.assertEqual(len(routing_grid), 3)
        # Width should match GRID_WIDTH
        self.assertEqual(len(routing_grid[0]), self.config.GRID_WIDTH * 2 - 1)

    def test_get_routing_grid(self):
        routing_grid = self.routing_grid.get_routing_grid()
        # Length should match number of points in path
        self.assertEqual(len(routing_grid), 3)
        # Width should match GRID_WIDTH
        self.assertEqual(len(routing_grid[0]), self.config.GRID_WIDTH * 2 - 1)

\end{minted}
\section{performance_model}
\subsection{contrails.py}
\begin{minted}[breaklines,fontsize=\small]{python}
import pandas as pd
import requests
import xarray as xr
import pycontrails as pc
from pycontrails.models.cocip import Cocip
from pycontrails.models.humidity_scaling import ConstantHumidityScaling
import os
import tempfile
import json
from pycontrails.models.ps_model import PSGrid
from rich import print
import typing

from utils import Conversions

if typing.TYPE_CHECKING:
    from .weather import WeatherGrid
    from config import Config
    from _types import FlightPath, FlightPoint, Point3D, Grid2D


class CocipManager:
    def __init__(self, weather_grid: "WeatherGrid", config: "Config"):
        """
        Wrapper around the CoCiP model from pycontrails
        """
        self.config: "Config" = config
        self.met: xr.Dataset = weather_grid.met
        self.rad: xr.Dataset = weather_grid.rad

    def calculate_ef_from_flight_path(self, flight_path: "FlightPath") -> tuple:
        """
        Runs CoCiP on a given flight path
        """
        flight_path_df = pd.DataFrame(flight_path)

        attrs = {
            "flight_id": 123,
            "aircraft_type": self.config.AIRCRAFT_TYPE,
            "wingspan": self.config.WINGSPAN,
            "nvpm_ei_n": 1.897264e15,
            "n_engine": self.config.N_ENGINES,
            "engine_efficiency": self.config.NOMINAL_ENGINE_EFFICIENCY,
        }

        flight = pc.Flight(data=flight_path_df, flight_id=123, attrs=attrs)

        params = {
            "process_emissions": False,
            "radiative_heating_effects": True,
            "humidity_scaling": ConstantHumidityScaling(rhi_adj=0.98),
        }
        cocip = Cocip(self.met, self.rad, params=params)
        output_flight = cocip.eval(source=flight)

        df = output_flight.dataframe
        if not df["ef"].empty:
            ef = df["ef"].sum()
        else:
            ef = 0

        return ef, df, cocip


class PSGridManager:
    def __init__(self, weather_grid: "WeatherGrid", config: "Config"):
        """
        Retrieves a performance grid for a given weather grid
        """
        self.config: "Config" = config
        self.ps_grid: xr.Dataset = self._get_ps_grid(weather_grid)

    def _get_ps_grid(self, weather_grid: "WeatherGrid") -> xr.Dataset:
        """
        Calculates the PS grid, or retrieves it if it already exists
        """
        if os.path.exists("data/ps_grid.nc"):
            return xr.open_dataset("data/ps_grid.nc")
        else:
            ps_grid = PSGrid(
                weather_grid.met, aircraft_type=self.config.AIRCRAFT_TYPE
            ).eval()
            ps_grid.data.to_netcdf("data/ps_grid.nc")
            return xr.open_dataset("data/ps_grid.nc")

    def get_performance_data_at_point(self, point: "FlightPoint") -> xr.Dataset:
        """
        Retrieves performance data at a given point
        """
        level = Conversions().convert_altitude_to_pressure_bounded(
            point["altitude_ft"],
            self.config.PRESSURE_LEVELS[-1],
            self.config.PRESSURE_LEVELS[0],
        )

        performance_data = self.ps_grid.interp(
            latitude=point["latitude"],
            longitude=point["longitude"],
            level=level,
            time=point["time"],
        )

        return performance_data


class ContrailGrid:
    def __init__(self, contrail_grid: xr.Dataset):
        """
        Wrapper around the 4D contrail grid dataset
        """
        self.contrail_grid: xr.Dataset = contrail_grid

    def interpolate_contrail_point(
        self,
        point: "Point3D",
    ) -> float:
        """
        Interpolates the ef_per_m at a flight point
        """
        da = self.contrail_grid["ef_per_m"]
        ef_per_m = da.interp(
            latitude=point[0], longitude=point[1], flight_level=point[2] / 100
        )
        return ef_per_m.sum().item()

    def interpolate_contrail_grid(
        self,
        flight_path: "FlightPath",
    ) -> float:
        """
        Interpolates a flight path against the contral grid, to get a total ef for the flight
        """
        da = self.contrail_grid["ef_per_m"]

        flight_path = pd.DataFrame(
            flight_path,
            columns=["latitude", "longitude", "altitude_ft", "time", "segment_length"],
        )

        fl_ds = flight_path.copy()
        fl_ds.pop("segment_length")
        fl_ds["flight_level"] = fl_ds.pop("altitude_ft") / 100
        fl_ds = xr.Dataset.from_dataframe(fl_ds)

        ef_per_m = da.interp(**fl_ds.data_vars)
        total_flight = ef_per_m * flight_path["segment_length"]

        return total_flight.sum().item()


class ContrailGridManager:
    def __init__(self, routing_grid: "Grid2D", config: "Config"):
        """
        Wrapper for the contrail grid and contrail polys
        """
        self.config: "Config" = config
        self.routing_grid: "Grid2D" = routing_grid
        self.contrail_polys: dict = self._get_contrail_polys()
        self.contrail_grid: ContrailGrid = ContrailGrid(self._get_contrail_grid())

    def _get_contrail_grid(self) -> xr.Dataset:
        """
        Downloads the contrail grid or retrieves it
        """
        if os.path.exists("data/contrail_grid.nc"):
            return xr.open_dataset("data/contrail_grid.nc")
        else:
            contrail_grid = self._download_contrail_grid()
            contrail_grid.to_netcdf("data/contrail_grid.nc")
            return contrail_grid

    def _get_contrail_polys(self) -> dict:
        """
        Downloads the contrail polys or retrieves it
        """
        if os.path.exists("data/contrail_polys.json"):
            with open("data/contrail_polys.json", "r") as f:
                return json.load(f)
        else:
            contrail_polys = self._download_contrail_grid(format="geojson")
            with open("data/contrail_polys.json", "w") as f:
                json.dump(contrail_polys, f)
            return contrail_polys

    def _download_contrail_grid(self, format: str = "netcdf") -> xr.Dataset or dict:
        """
        Downloads the contrail polys or grid from the pycontrails API
        """
        URL = os.getenv("API_URL_BASE")
        api_key = os.getenv("API_KEY")
        headers = {"x-api-key": api_key}

        grid = sum(self.routing_grid, [])
        grid_df = pd.DataFrame(grid, columns=["latitude", "longitude"])
        params = {
            "bbox": [
                grid_df["longitude"].min() - 1,
                grid_df["latitude"].min() - 1,
                grid_df["longitude"].max() + 1,
                grid_df["latitude"].max() + 1,
            ],
            "flight_level": self.config.FLIGHT_LEVELS,
            "aircraft_type": self.config.AIRCRAFT_TYPE,
            "format": format,
        }

        ds_list = []
        timerange = [
            self.config.DEPARTURE_DATE,
            self.config.DEPARTURE_DATE + self.config.WEATHER_BOUND,
        ]
        times = pd.date_range(timerange[0], timerange[1], freq="1h")
        for t in times:
            params["time"] = str(t)
            r = requests.get(f"{URL}/grid/cocip", params=params, headers=headers)
            print(f"HTTP Response Code: {r.status_code} {r.reason}")
            # Save request to disk, open with xarray, append grid to ds_list
            if format == "netcdf":
                with tempfile.NamedTemporaryFile() as tmp, open(
                    tmp.name, "wb"
                ) as file_obj:
                    file_obj.write(r.content)
                    ds = xr.load_dataset(
                        tmp.name, engine="netcdf4", decode_timedelta=False
                    )
                ds_list.append(ds)
            else:
                geojson = r.json()
                for feature in geojson["features"]:
                    for coords in feature["geometry"]["coordinates"]:
                        for poly in coords:
                            for point in poly:
                                del point[2]
                    ds_list.append(feature)

        # Concatenate all grids into a single xr.Dataset
        if format == "netcdf":
            ds = xr.concat(ds_list, dim="time")
        if format == "geojson":
            combined_dict = {"polys": ds_list}
            ds = combined_dict

        return ds

\end{minted}
\subsection{flight.py}
\begin{minted}[breaklines,fontsize=\small]{python}
import random
import pandas as pd
from utils import Conversions
import typing

if typing.TYPE_CHECKING:
    from routing_graph import RoutingGraphManager
    from _types import FlightPath, IndexPath, Objectives, IndexPoint3D
    from config import Config
    from performance_model import PerformanceModel


class Flight:
    def __init__(
        self,
        routing_graph_manager: "RoutingGraphManager",
        flight_path: "FlightPath",
        config: "Config",
    ):
        """
        Class to hold a flight path and relevant objective information
        """
        self.routing_graph_manager: "RoutingGraphManager" = routing_graph_manager
        self.performance_model: "PerformanceModel" = (
            routing_graph_manager.get_performance_model()
        )
        self.flight_path: "FlightPath" = flight_path
        self.config: "Config" = config
        self.indices: "IndexPath" = []
        self.objectives: "Objectives" or None = None

    def set_departure(self, departure: "IndexPoint3D") -> None:
        """
        Sets the departure point for the flight path
        """
        self.add_point_from_index(departure)
        point = self.flight_path[0]
        point["time"] = self.config.DEPARTURE_DATE
        point["aircraft_mass"] = self.config.STARTING_WEIGHT
        self.flight_path[0] = point

    def run_performance_model(self) -> None:
        """
        Runs the performance model on the flight path
        """
        self.flight_path = self.performance_model.run_apm(self.flight_path)

    def add_point_from_index(self, index: "IndexPoint3D") -> None:
        """
        Adds an index point to the index path
        """
        self.indices.append(index)
        point = self.routing_graph_manager.convert_index_to_point(
            index,
        )
        self.flight_path.append(point)

    def calculate_objectives(self) -> "Objectives":
        """
        Calculates the objective values for this flight path
        """
        objectives = {}
        for objective in self.config.OBJECTIVES:
            objective = objective(self.performance_model, self.config)
            objective_name = str(objective)
            objective_value = objective._run_objective_function(self.flight_path)
            objectives[objective_name] = objective_value

        self.objectives = objectives
        return objectives


class RealFlight(Flight):
    def __init__(
        self,
        flight_name: str,
        routing_graph_manager: "RoutingGraphManager",
        config: "Config",
    ):
        super().__init__(
            routing_graph_manager,
            [],
            config,
        )
        self.flight_path = pd.read_csv(f"data/{flight_name}")
        self.flight_path: "FlightPath" = self.convert_real_flight_path()
        self.config: "Config" = config

    def convert_real_flight_path(self) -> "FlightPath":
        """
        Converts a dataframe of a real flight path to a list of dictionaries
        """
        path = []
        for _, row in self.flight_path.iterrows():
            path_point = {
                "latitude": row["latitude"],
                "longitude": row["longitude"],
                "altitude_ft": row["altitude_ft"],
                "thrust": self.config.NOMINAL_THRUST,
                "time": row["time"],
                "level": Conversions().convert_altitude_to_pressure_bounded(
                    row["altitude_ft"],
                    self.config.PRESSURE_LEVELS[-1],
                    self.config.PRESSURE_LEVELS[0],
                ),
            }

            path.append(path_point)

        return path


class RandomFlight(Flight):
    def __init__(self, routing_graph_manager, config):
        super().__init__(
            routing_graph_manager,
            [],
            config,
        )
        self.routing_graph_manager = routing_graph_manager
        self.routing_graph = routing_graph_manager.get_routing_graph()
        self.config = config

    def construct_random_flight(self):
        self.set_departure((0, self.config.GRID_WIDTH, self.config.STARTING_ALTITUDE))
        consecutive_points = self.routing_graph[self.indices[0]]

        while consecutive_points != {}:
            choice = random.choice(list(consecutive_points))
            self.add_point_from_index(choice)
            consecutive_points = self.routing_graph[choice]

        return self.flight_path

\end{minted}
\subsection{weather.py}
\begin{minted}[breaklines,fontsize=\small]{python}
import os
from pycontrails.models.cocip import Cocip
from pycontrails.datalib.ecmwf import ERA5
from pycontrails.core.met import MetDataset
import pandas as pd
import xarray as xr
import typing

from routing_graph import AltitudeGrid

if typing.TYPE_CHECKING:
    from config import Config
    from _types import FlightPoint, WindVector


class WeatherGrid:
    def __init__(self, altitude_grid: "AltitudeGrid", config: "Config"):
        """
        Class to interpolate weather data along the routing grid
        """
        self.config: "Config" = config
        time_bounds = (
            self.config.DEPARTURE_DATE,
            self.config.DEPARTURE_DATE + self.config.WEATHER_BOUND,
        )
        pressure_levels = self.config.PRESSURE_LEVELS
        self.era5pl: ERA5 = ERA5(
            time=time_bounds,
            timestep_freq="1h",
            variables=Cocip.met_variables + Cocip.optional_met_variables,
            pressure_levels=pressure_levels,
        )
        self.era5sl: ERA5 = ERA5(time=time_bounds, variables=Cocip.rad_variables)
        self.met: MetDataset = self._get_met()
        self.rad: MetDataset = self._get_rad()
        self.altitude_grid: "AltitudeGrid" = altitude_grid

    def get_weather_grid(self) -> xr.Dataset:
        """
        Gets the weather data along the grid
        """
        self.weather_grid: xr.Dataset = self._init_weather_data_along_grid()
        return self.weather_grid

    def _get_met(self) -> MetDataset:
        """
        Retrieves the met dataset, or creates it if it doesn't exist
        """
        if not os.path.exists("data/met.nc"):
            met = self.era5pl.open_metdataset()

            met.data.to_netcdf("data/met.nc")
        else:
            met = xr.open_dataset("data/met.nc")
            met = MetDataset(met)

        return met

    def _get_rad(self) -> MetDataset:
        """
        Retrieves the met dataset, or creates it if it doesn't exist
        """
        if not os.path.exists("data/rad.nc"):
            rad = self.era5sl.open_metdataset()
            rad.data.to_netcdf("data/rad.nc")
        else:
            rad = xr.open_dataset("data/rad.nc")
            rad = MetDataset(rad)

        return rad

    def _init_weather_data_along_grid(self) -> xr.Dataset:
        """
        Initializes the weather data along the grid
        """
        if not os.path.exists("data/weather_data.nc"):
            grid = self.altitude_grid.altitude_grid.copy()
            for alt in grid:
                grid[alt] = [x for x in sum(grid[alt], []) if x is not None]

            grid = [
                (lat, lon, key) for key, values in grid.items() for lat, lon in values
            ]

            flight_path = pd.DataFrame(
                grid,
                columns=["latitude", "longitude", "altitude_ft"],
            )

            fl_ds = flight_path.copy()
            fl_ds = fl_ds.set_index(["altitude_ft", "latitude", "longitude"])
            fl_ds = xr.Dataset.from_dataframe(fl_ds)
            weather = self.met.data.interp(**fl_ds.data_vars)

            weather.to_netcdf("data/weather_data.nc")

        weather_data = xr.open_dataset("data/weather_data.nc")

        return weather_data

    def get_weather_data_at_point(self, point: "FlightPoint") -> xr.Dataset:
        """
        Gets the weather data at a point in the grid
        """
        data = self.weather_grid.sel(
            latitude=point["latitude"],
            longitude=point["longitude"],
            time=point["time"],
            level=point["level"],
            method="nearest",
        )
        return data

    def get_wind_vector_at_point(self, point: xr.Dataset) -> "WindVector":
        """
        Gets the wind vector at a point and returns it as a tuple
        """
        u = point["eastward_wind"].values
        v = point["northward_wind"].values

        return (u, v)

    def get_temperature_at_point(self, point: xr.Dataset) -> float:
        """
        Gets the temperature at a point and returns it
        """
        temperature = point["air_temperature"].values
        return temperature

\end{minted}
\subsection{__init__.py}
\begin{minted}[breaklines,fontsize=\small]{python}
import xarray as xr
import typing

from .apm import AircraftPerformanceModel
from .contrails import CocipManager, ContrailGridManager, PSGridManager, ContrailGrid
from .weather import WeatherGrid
from .flight import RealFlight, Flight, RandomFlight

if typing.TYPE_CHECKING:
    from config import Config
    from routing_graph import RoutingGraphManager, RoutingGrid, AltitudeGrid
    from _types import FlightPath


class PerformanceModel:
    def __init__(self, routing_graph_manager: "RoutingGraphManager", config: "Config"):
        """
        Wrapper for all the performance model classes
        """
        self.config: "Config" = config
        self.routing_grid: "RoutingGrid" = routing_graph_manager.get_routing_grid()
        self.altitude_grid: "AltitudeGrid" = routing_graph_manager.get_altitude_grid()
        self.routing_graph_manager: "RoutingGraphManager" = routing_graph_manager
        self.get_apm()
        self.get_weather_grid()
        self.get_ps_grid()
        self.get_cocip_manager()
        self.get_contrail_grid_manager()
        self.get_contrail_grid()

    def run_apm(self, flight_path: "FlightPath") -> "FlightPath":
        """
        Runs the Aircraft Performance Model on a flight path
        """
        return self.apm.calculate_flight_characteristics(flight_path)

    def get_contrail_polys(self) -> xr.Dataset:
        """
        Gets contrail polygons
        """
        return self.contrail_manager.contrail_polys

    def get_ps_grid(self) -> PSGridManager:
        """
        Gets the PS grid
        """
        if hasattr(self, "ps_grid") is False:
            weather_grid = self.get_weather_grid()
            self.ps_grid = PSGridManager(weather_grid, self.config)
        return self.ps_grid

    def get_apm(self) -> AircraftPerformanceModel:
        """
        Gets the Aircraft Performance model
        """
        if hasattr(self, "apm") is False:
            weather_grid = self.get_weather_grid()
            self.apm = AircraftPerformanceModel(weather_grid, self.config)
        return self.apm

    def get_weather_grid(self) -> WeatherGrid:
        """
        Gets the weather grid
        """
        if hasattr(self, "weather_grid") is False:
            self.weather_grid = WeatherGrid(self.altitude_grid, self.config)
            self.weather_grid.get_weather_grid()
        return self.weather_grid

    def get_cocip_manager(self) -> CocipManager:
        """
        Gets the CoCiP manager
        """
        if hasattr(self, "cocip_manager") is False:
            weather_grid = self.get_weather_grid()
            self.cocip_manager = CocipManager(weather_grid, self.config)
        return self.cocip_manager

    def get_contrail_grid(self) -> ContrailGrid:
        """
        Gets the contrail grid
        """
        if hasattr(self, "contrail_grid") is False:
            contrail_manager = self.get_contrail_grid_manager()
            self.contrail_grid = contrail_manager.contrail_grid
        return self.contrail_grid

    def get_contrail_grid_manager(self) -> ContrailGridManager:
        """
        Gets the contrail grid manager
        """
        if hasattr(self, "contrail_manager") is False:
            self.contrail_manager = ContrailGridManager(
                self.routing_grid.get_routing_grid(), self.config
            )
        return self.contrail_manager

\end{minted}
\subsection{apm.py}
\begin{minted}[breaklines,fontsize=\small]{python}
from geopy import distance as gp
import pandas as pd
import numpy as np
from openap import FuelFlow, Emission
import math
import pycontrails as pc
import typing

from utils import Conversions
from .weather import WeatherGrid

if typing.TYPE_CHECKING:
    from config import Config
    from _types import FlightPoint, FlightPath, WindVector, Point2D


class AircraftPerformanceModel:
    def __init__(self, weather_grid: "WeatherGrid", config: "Config"):
        self.weather_grid: "WeatherGrid" = weather_grid
        self.config: "Config" = config

    def calculate_flight_characteristics(
        self, flight_path: "FlightPath"
    ) -> "FlightPath":
        """
        Calculate flight characteristics for the whole flight path
        """

        flight_path = self.calculate_coarse_characteristics(flight_path)
        if flight_path[0]["segment_length"] > 100000:
            flight_path = self.resample(flight_path)
        fuelflow = FuelFlow(ac=self.config.AIRCRAFT_TYPE)
        emission = Emission(ac=self.config.AIRCRAFT_TYPE)
        for i, point in enumerate(flight_path):
            if i != len(flight_path) - 1:
                next_point = flight_path[i + 1]
            else:
                next_point = None

            if i == 0:
                previous_point = None
            else:
                previous_point = flight_path[i - 1]

            point = self.recalculate_flight_characteristics(i, point, next_point)

            point = self.calculate_emission_data(
                i, point, previous_point, emission, fuelflow
            )

        return flight_path

    def calculate_coarse_characteristics(
        self, flight_path: "FlightPath"
    ) -> "FlightPath":
        """
        Calculate basic initial characteristics for the first flight path
        """
        for i in range(len(flight_path)):
            point = flight_path[i]

            if i != len(flight_path) - 1:
                next_point = flight_path[i + 1]
                point["course"] = self.calculate_course_at_point(point, next_point)
                point["climb_angle"] = self.calculate_climb_angle(point, next_point)
                point["segment_length"] = self.calculate_segment_length(
                    next_point, point
                )
            else:
                point["segment_length"] = 0
                point["course"] = 0
                point["climb_angle"] = 0

            if i == 0:
                point["time"] = self.config.DEPARTURE_DATE
            else:
                previous_point = flight_path[i - 1]
                time_elapsed = self.calculate_time_at_point(point, previous_point)
                point["time"] = previous_point["time"] + time_elapsed.round("s")

            weather_at_point = self.weather_grid.get_weather_data_at_point(point)
            temperature = self.weather_grid.get_temperature_at_point(weather_at_point)
            wind_vector = self.weather_grid.get_wind_vector_at_point(weather_at_point)

            point["true_airspeed"] = self.calculate_true_air_speed(
                point["thrust"], temperature
            )
            crabbing_angle = self.calculate_crabbing_angle(point, wind_vector)
            point["heading"] = point["course"] - crabbing_angle
            point["ground_speed"] = self.calculate_ground_speed(point, wind_vector)

        return flight_path

    def recalculate_flight_characteristics(
        self, i: int, point: "FlightPoint", next_point: "FlightPoint"
    ) -> "FlightPoint":
        """
        Recalculate several flight characteristics for the new resampled flight path
        """
        if next_point is not None:
            point["course"] = self.calculate_course_at_point(point, next_point)
            point["climb_angle"] = self.calculate_climb_angle(point, next_point)
            point["segment_length"] = self.calculate_segment_length(next_point, point)
        else:
            point["segment_length"] = 0
            point["course"] = 0
            point["climb_angle"] = 0

        point["level"] = Conversions().convert_altitude_to_pressure_bounded(
            point["altitude_ft"],
            self.config.PRESSURE_LEVELS[-1],
            self.config.PRESSURE_LEVELS[0],
        )
        weather_at_point = self.weather_grid.get_weather_data_at_point(point)
        temperature = self.weather_grid.get_temperature_at_point(weather_at_point)
        wind_vector = self.weather_grid.get_wind_vector_at_point(weather_at_point)
        point["thrust"] = self.config.NOMINAL_THRUST

        point["true_airspeed"] = self.calculate_true_air_speed(
            point["thrust"], temperature
        )
        crabbing_angle = self.calculate_crabbing_angle(point, wind_vector)
        point["heading"] = point["course"] - crabbing_angle
        point["ground_speed"] = self.calculate_ground_speed(point, wind_vector)
        return point

    def calculate_emission_data(
        self,
        i: int,
        point: "FlightPoint",
        previous_point: "FlightPoint",
        emission: "Emission",
        fuelflow: "FuelFlow",
    ) -> "FlightPoint":
        """
        Calculate emissions for the new resampled flight path
        """
        if i == 0:
            point["aircraft_mass"] = self.config.STARTING_WEIGHT
            fuel_flow = self.calculate_fuel_flow(
                point, point["aircraft_mass"], fuelflow
            )
            point["fuel_flow"] = fuel_flow
            point["CO2"] = self.calculate_emissions(fuel_flow, emission)
        else:
            fuel_flow = self.calculate_fuel_flow(
                point, previous_point["aircraft_mass"], fuelflow
            )
            time_elapsed = pd.Timedelta(point["time"] - previous_point["time"]).seconds
            point["fuel_flow"] = fuel_flow
            point["CO2"] = (
                self.calculate_emissions(fuel_flow, emission) * time_elapsed
            ) / 1000  # kg
            point["aircraft_mass"] = (
                previous_point["aircraft_mass"] - point["fuel_flow"] * time_elapsed
            )

        return point

    def resample(self, flight_path: "FlightPath") -> "FlightPath":
        """
        Resamples a coarse flight path to a path with points every minute
        """
        flight_path_df = pd.DataFrame(flight_path)

        flight = pc.Flight(
            flight_path_df,
        )
        resample_path = flight.resample_and_fill(
            "1min", nominal_rocd=4.45
        )  # Calculated through trial and error
        resample_df = resample_path.dataframe
        resample_df["altitude_ft"] = resample_df["altitude"] * 3.28084
        resample_path = resample_df.to_dict("records")
        return resample_path

    def calculate_segment_length(
        self, point: "FlightPoint", previous_point: "FlightPoint"
    ) -> float:
        """
        Calculates the segment length between two points
        """
        flat_distance = gp.distance(
            (point["latitude"], point["longitude"]),
            (previous_point["latitude"], previous_point["longitude"]),
        ).m
        euclidean_distance = math.sqrt(
            flat_distance**2
            + ((point["altitude_ft"] - previous_point["altitude_ft"]) / 3.281) ** 2
        )
        return euclidean_distance

    def calculate_time_at_point(
        self, point: "FlightPoint", previous_point: "FlightPoint"
    ) -> pd.Timedelta:
        """
        Calculates the time between two points
        """
        distance = gp.distance(
            (point["latitude"], point["longitude"]),
            (previous_point["latitude"], previous_point["longitude"]),
        ).m
        time_from_previous_point = pd.Timedelta(
            seconds=distance / previous_point["ground_speed"]
        )
        return time_from_previous_point

    def calculate_bearing(self, p1: "Point2D", p2: "Point2D"):
        """
        Calculates the bearing between two points
        """
        lat1, lon1 = p1
        lat2, lon2 = p2
        delta_lon = lon2 - lon1

        lat1 = np.radians(lat1)
        lat2 = np.radians(lat2)
        delta_lon = np.radians(delta_lon)

        x = np.cos(lat1) * np.sin(lat2) - np.sin(lat1) * np.cos(lat2) * np.cos(
            delta_lon
        )
        y = np.sin(delta_lon) * np.cos(lat1)
        z = np.arctan2(y, x) % (2 * np.pi)  # Convert to range [0, 2pi]

        return z

    def calculate_course_at_point(
        self, point: "FlightPoint", next_point: "FlightPoint"
    ) -> float:
        """
        Calculates the course between two points
        """
        bearing = self.calculate_bearing(
            (point["longitude"], point["latitude"]),
            (next_point["longitude"], next_point["latitude"]),
        )
        return bearing

    def calculate_true_air_speed(self, mach: float, temperature: float) -> float:
        """
        Calculates the true air speed for a given MACH value and temperature
        """
        speed_of_sound = 340.29
        sea_level_temp = 288.15  # in kelvin
        air_temp_ratio = temperature / sea_level_temp

        true_air_speed = mach * speed_of_sound * np.sqrt(air_temp_ratio)
        return true_air_speed  # in m/s

    def calculate_crabbing_angle(
        self, point: "FlightPoint", wind_vector: "WindVector"
    ) -> float:
        """
        Calculates the crabbing angle accounting for wind
        """
        u, v = wind_vector
        numerator = (v * np.sin(point["course"])) - (u * np.cos(point["course"]))
        crabbing_angle = np.arcsin(numerator / point["true_airspeed"])
        return crabbing_angle

    def calculate_climb_angle(
        self, point: "FlightPoint", next_point: "FlightPoint"
    ) -> float:
        """
        Calculates the climb angle between two points
        """
        change_in_altitude = next_point["altitude_ft"] - point["altitude_ft"]
        change_in_altitude_km = change_in_altitude / 3281
        distance = gp.distance(
            (point["latitude"], point["longitude"]),
            (next_point["latitude"], next_point["longitude"]),
        ).km
        angle = np.arctan2(change_in_altitude_km, distance)
        return angle

    def calculate_ground_speed(
        self, point: "FlightPoint", wind_vector: "WindVector"
    ) -> float:
        """
        Calculates the ground speed of a point, accounting for wind
        """
        u, v = wind_vector
        climb_angle = point["climb_angle"]
        first_component = v * np.cos(point["course"]) + u * np.sin(point["course"])
        second_component = np.sqrt(
            np.power((point["true_airspeed"] * np.cos(climb_angle)), 2)
            - np.power(
                ((v * np.sin(point["course"])) - (u * np.cos(point["course"]))), 2
            )
        )
        ground_speed = first_component + second_component
        return ground_speed

    def calculate_emissions(self, FF: float, emission: "Emission") -> float:
        """
        Calculates the emissinos of a point
        """
        return emission.co2(FF)  # g/s

    def calculate_fuel_flow(
        self, point: "FlightPoint", mass: float, fuelflow: "FuelFlow"
    ) -> float:
        """
        Calculates the fuel flow of a point
        """

        FF = fuelflow.enroute(
            mass=mass,
            alt=point["altitude_ft"],
            tas=point["true_airspeed"],
            path_angle=point["heading"],
        )
        return FF

\end{minted}
\subsection{Tests}
\subsubsection{__init__.py}
\begin{minted}[breaklines,fontsize=\small]{python}

\end{minted}
\subsubsection{test_flight.py}
\begin{minted}[breaklines,fontsize=\small]{python}
import unittest
from unittest.mock import MagicMock
from ..flight import Flight, RealFlight
from config import Config


class TestFlight(unittest.TestCase):
    def setUp(self):
        class MockRoutingGraphManager:
            def convert_index_to_point(self, index):
                return {
                    "latitude": 0,
                    "longitude": 0,
                    "altitude_ft": 0,
                    "thrust": 1,
                    "level": 0,
                }

            def get_performance_model(self):
                return MagicMock()

        class MockConfig(Config):
            DEPARTURE_DATE = "2024-01-01"
            STARTING_WEIGHT = 100000

        self.mock_routing_graph_manager = MockRoutingGraphManager()
        self.mock_config = MockConfig()

    def test_set_departure(self):
        flight = Flight(self.mock_routing_graph_manager, [], self.mock_config)
        flight.set_departure((0, 0, 0))
        # Assert departure point is correctly set
        self.assertEqual(len(flight.flight_path), 1)
        self.assertEqual(flight.flight_path[0]["latitude"], 0)
        self.assertEqual(flight.flight_path[0]["longitude"], 0)
        self.assertEqual(flight.flight_path[0]["altitude_ft"], 0)
        self.assertEqual(flight.flight_path[0]["thrust"], 1)
        self.assertEqual(flight.flight_path[0]["time"], "2024-01-01")
        self.assertEqual(flight.flight_path[0]["aircraft_mass"], 100000)

    def test_run_performance_model(self):
        flight = Flight(self.mock_routing_graph_manager, [], self.mock_config)
        flight.performance_model.run_apm = MagicMock()
        flight.run_performance_model()
        # Assert performance model is run
        flight.performance_model.run_apm.assert_called_once_with([])

    def test_add_point_from_index(self):
        flight = Flight(self.mock_routing_graph_manager, [], self.mock_config)
        flight.routing_graph_manager.convert_index_to_point = MagicMock(
            return_value={
                "latitude": 1,
                "longitude": 1,
                "altitude_ft": 1,
                "thrust": 1,
                "level": 1,
            }
        )

        flight.add_point_from_index((1, 1, 1))
        # Assert point is correctly added from index
        self.assertEqual(len(flight.flight_path), 1)
        self.assertEqual(flight.flight_path[0]["latitude"], 1)
        self.assertEqual(flight.flight_path[0]["longitude"], 1)
        self.assertEqual(flight.flight_path[0]["altitude_ft"], 1)
        self.assertEqual(flight.flight_path[0]["thrust"], 1)


class TestRealFlight(unittest.TestCase):
    def setUp(self):
        class MockRoutingGraphManager:
            def convert_index_to_point(self, index):
                return {
                    "latitude": 0,
                    "longitude": 0,
                    "altitude_ft": 0,
                    "thrust": 1,
                    "level": 1,
                }

            def get_performance_model(self):
                return MagicMock()

        class MockConfig(Config):
            NOMINAL_THRUST = 1
            PRESSURE_LEVELS = [0, 1]

        self.mock_routing_graph_manager = MockRoutingGraphManager()
        self.mock_config = MockConfig()

    def test_convert_real_flight_path(self):
        real_flight = RealFlight(
            "test-flight.csv", self.mock_routing_graph_manager, self.mock_config
        )
        # Assert real flight path is correctly converted
        self.assertEqual(len(real_flight.flight_path), 2)
        self.assertEqual(real_flight.flight_path[0]["latitude"], 50)
        self.assertEqual(real_flight.flight_path[0]["longitude"], -3)
        self.assertEqual(real_flight.flight_path[0]["altitude_ft"], 30551)
        self.assertEqual(real_flight.flight_path[0]["thrust"], 1)
        self.assertEqual(real_flight.flight_path[0]["level"], 1)

\end{minted}
\subsubsection{test_apm.py}
\begin{minted}[breaklines,fontsize=\small]{python}
import unittest
import pandas as pd
from ..apm import AircraftPerformanceModel


class TestAircraftPerformanceModel(unittest.TestCase):
    def setUp(self):
        class MockWeatherGrid:
            def get_weather_data_at_point(self, point):
                return {"temperature": 25, "wind_u": 10, "wind_v": 5}

            def get_temperature_at_point(self, weather_data):
                return weather_data["temperature"]

            def get_wind_vector_at_point(self, weather_data):
                return weather_data["wind_u"], weather_data["wind_v"]

        class MockConfig:
            DEPARTURE_DATE = pd.Timestamp(
                year=2024, month=1, day=31, hour=13, minute=45, second=57
            )
            NOMINAL_ENGINE_EFFICIENCY = 0.85
            STARTING_WEIGHT = 100000
            AIRCRAFT_TYPE = "A320"
            PRESSURE_LEVELS = [0, 1, 2, 3]
            NOMINAL_THRUST = 1

        self.mock_weather_grid = MockWeatherGrid()
        self.mock_config = MockConfig()

    def test_calculate_flight_characteristics(self):
        apm = AircraftPerformanceModel(self.mock_weather_grid, self.mock_config)
        flight_path = [
            {"latitude": 0, "longitude": 0, "altitude_ft": 0, "thrust": 1},
            {"latitude": 1, "longitude": 1, "altitude_ft": 10000, "thrust": 1},
        ]
        flight_path = apm.calculate_flight_characteristics(flight_path)
        # Assert flight characteristics are calculated correctly
        self.assertEqual(len(flight_path), 23)
        self.assertIn("course", flight_path[0])
        self.assertIn("climb_angle", flight_path[0])
        self.assertIn("time", flight_path[0])
        self.assertIn("true_airspeed", flight_path[0])
        self.assertIn("heading", flight_path[0])
        self.assertIn("ground_speed", flight_path[0])
        self.assertIn("fuel_flow", flight_path[0])
        self.assertIn("CO2", flight_path[0])
        self.assertIn("aircraft_mass", flight_path[0])

\end{minted}
\subsection{__init__.py}
\begin{minted}[breaklines,fontsize=\small]{python}

\end{minted}
\subsection{test_flight.py}
\begin{minted}[breaklines,fontsize=\small]{python}
import unittest
from unittest.mock import MagicMock
from ..flight import Flight, RealFlight
from config import Config


class TestFlight(unittest.TestCase):
    def setUp(self):
        class MockRoutingGraphManager:
            def convert_index_to_point(self, index):
                return {
                    "latitude": 0,
                    "longitude": 0,
                    "altitude_ft": 0,
                    "thrust": 1,
                    "level": 0,
                }

            def get_performance_model(self):
                return MagicMock()

        class MockConfig(Config):
            DEPARTURE_DATE = "2024-01-01"
            STARTING_WEIGHT = 100000

        self.mock_routing_graph_manager = MockRoutingGraphManager()
        self.mock_config = MockConfig()

    def test_set_departure(self):
        flight = Flight(self.mock_routing_graph_manager, [], self.mock_config)
        flight.set_departure((0, 0, 0))
        # Assert departure point is correctly set
        self.assertEqual(len(flight.flight_path), 1)
        self.assertEqual(flight.flight_path[0]["latitude"], 0)
        self.assertEqual(flight.flight_path[0]["longitude"], 0)
        self.assertEqual(flight.flight_path[0]["altitude_ft"], 0)
        self.assertEqual(flight.flight_path[0]["thrust"], 1)
        self.assertEqual(flight.flight_path[0]["time"], "2024-01-01")
        self.assertEqual(flight.flight_path[0]["aircraft_mass"], 100000)

    def test_run_performance_model(self):
        flight = Flight(self.mock_routing_graph_manager, [], self.mock_config)
        flight.performance_model.run_apm = MagicMock()
        flight.run_performance_model()
        # Assert performance model is run
        flight.performance_model.run_apm.assert_called_once_with([])

    def test_add_point_from_index(self):
        flight = Flight(self.mock_routing_graph_manager, [], self.mock_config)
        flight.routing_graph_manager.convert_index_to_point = MagicMock(
            return_value={
                "latitude": 1,
                "longitude": 1,
                "altitude_ft": 1,
                "thrust": 1,
                "level": 1,
            }
        )

        flight.add_point_from_index((1, 1, 1))
        # Assert point is correctly added from index
        self.assertEqual(len(flight.flight_path), 1)
        self.assertEqual(flight.flight_path[0]["latitude"], 1)
        self.assertEqual(flight.flight_path[0]["longitude"], 1)
        self.assertEqual(flight.flight_path[0]["altitude_ft"], 1)
        self.assertEqual(flight.flight_path[0]["thrust"], 1)


class TestRealFlight(unittest.TestCase):
    def setUp(self):
        class MockRoutingGraphManager:
            def convert_index_to_point(self, index):
                return {
                    "latitude": 0,
                    "longitude": 0,
                    "altitude_ft": 0,
                    "thrust": 1,
                    "level": 1,
                }

            def get_performance_model(self):
                return MagicMock()

        class MockConfig(Config):
            NOMINAL_THRUST = 1
            PRESSURE_LEVELS = [0, 1]

        self.mock_routing_graph_manager = MockRoutingGraphManager()
        self.mock_config = MockConfig()

    def test_convert_real_flight_path(self):
        real_flight = RealFlight(
            "test-flight.csv", self.mock_routing_graph_manager, self.mock_config
        )
        # Assert real flight path is correctly converted
        self.assertEqual(len(real_flight.flight_path), 2)
        self.assertEqual(real_flight.flight_path[0]["latitude"], 50)
        self.assertEqual(real_flight.flight_path[0]["longitude"], -3)
        self.assertEqual(real_flight.flight_path[0]["altitude_ft"], 30551)
        self.assertEqual(real_flight.flight_path[0]["thrust"], 1)
        self.assertEqual(real_flight.flight_path[0]["level"], 1)

\end{minted}
\subsection{test_apm.py}
\begin{minted}[breaklines,fontsize=\small]{python}
import unittest
import pandas as pd
from ..apm import AircraftPerformanceModel


class TestAircraftPerformanceModel(unittest.TestCase):
    def setUp(self):
        class MockWeatherGrid:
            def get_weather_data_at_point(self, point):
                return {"temperature": 25, "wind_u": 10, "wind_v": 5}

            def get_temperature_at_point(self, weather_data):
                return weather_data["temperature"]

            def get_wind_vector_at_point(self, weather_data):
                return weather_data["wind_u"], weather_data["wind_v"]

        class MockConfig:
            DEPARTURE_DATE = pd.Timestamp(
                year=2024, month=1, day=31, hour=13, minute=45, second=57
            )
            NOMINAL_ENGINE_EFFICIENCY = 0.85
            STARTING_WEIGHT = 100000
            AIRCRAFT_TYPE = "A320"
            PRESSURE_LEVELS = [0, 1, 2, 3]
            NOMINAL_THRUST = 1

        self.mock_weather_grid = MockWeatherGrid()
        self.mock_config = MockConfig()

    def test_calculate_flight_characteristics(self):
        apm = AircraftPerformanceModel(self.mock_weather_grid, self.mock_config)
        flight_path = [
            {"latitude": 0, "longitude": 0, "altitude_ft": 0, "thrust": 1},
            {"latitude": 1, "longitude": 1, "altitude_ft": 10000, "thrust": 1},
        ]
        flight_path = apm.calculate_flight_characteristics(flight_path)
        # Assert flight characteristics are calculated correctly
        self.assertEqual(len(flight_path), 23)
        self.assertIn("course", flight_path[0])
        self.assertIn("climb_angle", flight_path[0])
        self.assertIn("time", flight_path[0])
        self.assertIn("true_airspeed", flight_path[0])
        self.assertIn("heading", flight_path[0])
        self.assertIn("ground_speed", flight_path[0])
        self.assertIn("fuel_flow", flight_path[0])
        self.assertIn("CO2", flight_path[0])
        self.assertIn("aircraft_mass", flight_path[0])

\end{minted}

